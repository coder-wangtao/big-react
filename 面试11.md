1.useMemo: 缓存值(可以实现手动 bailout，详见：面试 11-useMemo.jsx，3.手动 bailout ExpensiveSubtreeThree 满足了 bailout 四要素)
2.useCallback:缓存函数

3.bailout 和 ContextAPI
在旧版的 ContextApi 中，数据是保存在栈中的，在 beginWork 中 context 会不断的入栈，这意味着 context consumer 可以通过这个 context 栈找到对应的 context 数据。在 completeWork 中，context 会不断出栈，这种入栈出栈的模式，刚好对应的 reconcile 的流程以及一般的 bailout 策略
那么旧版的 ContextAPI 存在什么缺陷吗？
但是针对《跳过整颗子树的 beginWork 这种程度的 bailout 策略，被跳过的子树就不会再经历 context 的入栈出栈的过程，因此如果使用旧的 ContextApi,即使此时 context 里面的数据发生了变化，但是因为子树命中了 bailout 策略整颗被跳过了，所以子树中 context consumer 就不会响应更新》

新版的 ContextApi 中会做处理
在上面的代码中，首先会判断 context value 是否有变化，如果没有变化，会走 bailout 逻辑，当 context value 发生变化时，beginWork 会从 Provider 立刻向下开启一次深度优先遍历，目的就是为了寻找 context consumer，
如果一旦找到 context consumer，就对为对应的 FiberNode.lanes 上面附加一个 renderLanes。
之后 scheduleWorkOnParentPath 方法的作用是从 context consumer 向上遍历，依次为祖先的 fiberNode.childLanes 附加 renderLanes。

因此，我们来总结一下，当 context value 发生变化的时候，beginWork 从 Provider 开始向下遍历，找到 context consumer 之后为当前的 FiberNode 标记一个 renderLanes，
再从 context consumer 向上遍历，为祖先的 FiberNode.childLanes 标记一个 renderLanes。注意无论是向下遍历寻找 context consumer 还是从 context consumer 向上遍历修改 childLanes，这个都发生在 Provider 的 beginWork 中。因此，上述的流程完成后，虽然 Provider 命中了 bailout 策略，但是由于流程中 childLanes 已经被修改了，因此就不会命中“跳过整颗子树的 beginWork”的逻辑

"如果子树深处存在 context consumer"，即使子树的根 FiberNode 命中了 bailout 策略，由于存在 childLanes 的标记，
因此不会完全跳过子树的 beginWork 过程，所以新版的 ContextAPi 能实现更新，解决了旧版 ContextAP! 无法更新的问题。
