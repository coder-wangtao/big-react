1.优先级从何而来开？
不同交互对应不同的优先级
可以根据触发更新的上下文环境赋予不同的优先级，比如：点击事件需要同步处理，滚动事件的优先级再低点...
更进一步，还能推广到《可以触发更新的上下文环境》比如：
1.1useEffect create 回调中触发更新的优先级
1.2.首屏渲染的优先级

2.Scheduler 的 5 种优先级和 React Lane 模型
运行流程在 React 时，使用的是 Lane 模型，运行流程在 Scheduler 时，使用的是优先级。所以要实现这两者的转换。
为什么会有这两种优先级？
为了解耦

3.render 阶段可中断、高优先级打断低优先级

4.react18 默认启用同步更新(也就是微任务调度)，使用并发特性(useTransition)后的那次更新启用并发更新(scheduler 调度)

5.react 中事件优先级都是一样的吗？不是

<!--
function eventTypeToSchdulerPriority(eventType: string) {
  switch (eventType) {
    case "click":
    case "keydown":
    case "keyup":
      return unstable_ImmediatePriority;
    case "scroll":
      return unstable_UserBlockingPriority;
    default:
      return unstable_NormalPriority;
  }
}
-->

5.useTransition
关于可中断:
Concurrent 最主要的特点就是渲染是可中断的。没错，以前是不可中断的，也就是说，
以前 React 中的 update 是同步渲染，在这种情况下，一旦 update 开启，在任务完成前，都不可中断。
Concurrent 模式特点
先说可中断这件事情的重要性。对于 React 来说，任务可能很多，如果不区分优先级，那就是先来后到的顺序。
虽然听起来很合理，但是现实是普通车辆就应该给救护车让路，因为事有轻重缓急嘛。那么在 React 中呢，如果高优先级任务来了，
但是低优先级任务还没有处理完毕，就会造成高优先级任务等待的局面。比如说，某个低优先级任务还在缓慢中，
input 框忽然被用户触发，但是由于主线程被占着，没有人搭理用户，结果是用户哐哐输入，但是 input 没有任何反应。
用户一怒之下就走了，那你那个低优先级的任务还更新个什么呢，用户都没了。
由此可见，对于复杂项目来说，任务可中断这件事情很重要。那么问题来了，React 是如何做到的呢，
其实基础还是 fiber，fiber 本身链表结构，就是指针嘛，想指向别的地方加个属性值就行了。

关于被遗弃:
在 Concurrent 模式下，有些 update 可能会被遗弃掉。先举个 🌰：
比如说，我看电视的时候，切换遥控器，从 1 频道切换到 2 频道，再切换到 3 频道，最后在 4 频道停下来。
假如这些频道都是 UI，那么 2、3 频道的渲染其实我并不关心，我只关心 4 频道的结果，
如果你非要花时间把 2 和 3 频道的 UI 也渲染出来，最终导致 4 频道很久之后才渲染出来，那我肯定不开心。
正确的做法应该是尽快渲染 4 频道就行了，至于 2 和 3 频道，不管渲染了多少了，遗弃了就行了，反正也不需要了。
最后回到项目的实际场景，比如我想在淘宝搜索“老人与海”，那么我在输入框输入“老人与海”的过程中，“老人”会有对应的模糊查询结果，
但是不一定是我想要的结果，所以这个时候的模糊查询框的 update 就是低优先级，“老人”对应 UI 的 update 相对 input 的 update，
优先级就会低一些。在现在 React18 中，这个模糊查询相关的 UI 可以被当做 transition。关于 transition，等下我会有细讲。

const [isPending,startTransition] = useTransition()
startTransition(() => {
//setCount((count) => {
////return count + 1; a
//});
})
useTransition 內部会有一个状态 const [isPending, setPending] = mountState(false)，返回值是[isPending,startTransition],startTransition 保存 setPending 和用户传入的回调函数，startTransition 会以同步更新(也就是微任务调度)执行 setPending(true);使用并发更新(scheduler 调度)执行用户传入的回调函数和 setPending(false)
//当通过 startTransiton(() => setState(xxx)) 的方式触发更新时， react 就会采用 Concurrent 模式来协调 fiber tree。
//setState 触发更新时，react 都会为更新安排一个 task。触发更新的上下文不同，导致生成的 task 的优先级不同，相应的 task 的处理顺序也不相同。
//当通过 startTransition 的方式触发更新时，更新对应的优先级等级为 NormalPriority。而在 NormalPriority 之上，
// 还存在 ImmediatePriority 、UserBlockingPriority 这两种级别更高的更新。通常，高优先级的更新会优先级处理，
// 这就使得尽管 transition 更新先触发，但并不会在第一时间处理，而是处于 pending - 等待状态。
// 只有没有比 transition 更新优先级更高的更新存在时，它才会被处理。
//针对这种情况，我们可以使用 useTransition 返回的 isPending 来展示 transition 更新的状态。
// 当 isPending 为 ture 时，表示 transition 更新还未被处理，此时我们可以显示一个中间状态来优化用户体验；
// 当 isPending 为 false 时, 表示 transition 更新被处理，此时就可以显示实际需要的内容。

6.useRef
commitWork(commit 阶段有三个子阶段 1.beforeMutation;2.mutation;3.Layout)
mutation:修改真实 dom、解绑之前的 ref
Layout: useRef(绑定新 ref) useLayoutEffect 在这里执行

<!--
if (subtreeHasEffect || rootHasEffect) {
    // 阶段 1/3：beforeMutation

    // 阶段2/3： mutation Placement
    //修改真实dom
    //解绑之前的ref
    commitMutationEffects(finishedWork, root);
    root.current = finishedWork;
    // 阶段3/3:Layout useRef(绑定新ref) useLayoutEffect在这里执行
    commitLayoutEffects(finishedWork, root);
} -->
