1.react 中批处理（useState）
react 正常情况下时是在微任务中执行批处理的

<!--
setCount((count) => {
    return count + 1; a
});
setCount((count) => {
    return count + 1; b
});
setCount((count) => {
    return count + 1; c
});
-->

上面的例子，只会创建一个 update，这个 update 是一个双端环状列表，a->b->c=> a,这个双端环状列表默认执行最后一个(c)，c.next 就是第一个。当消费这个更新的时候，从 c.next(就是第一个)开始顺着 next 开始遍历，依次执行每一个回调，完成更新。
useState a => b => c => a => b => c 双端环状列表，为什么要这么设计？ 就是为了方便遍历。

多次触发更新，意味着对于同一个 Fiber,会创建多个 update，例如上面的例子，会创建多个 update；多次触发更新，只进行一次更新流程，意味着到达成三个目标：
《1》.需要实现一套优先级机制，每个更新都拥有优先级。
《2》.需要能够合并一个宏任务/微任务中触发的所有更新。
《3》.需要实现一套算法，用于决定哪个优先级优先进入 render 阶段。

setCount setCount setCount 三次 setState,会触发三次更新任务,[更新任务回调 1,更新任务回调 2,更新任务回调 3]形成一个数组,在微任务中取出数组里的每一个回调，依次执行。更新任务 1 执行完完毕后，会把当前任务的 lane 置为 NoLane，代表没有 update ，意味着没有更新。那么更新任务回调 2,更新任务回调 3 就不会执行了

但是使用 useTransition 之后，批处理是在宏任务中执行
const [isPending,startTransition] = useTransition()

<!--
startTransition(() => {
    setCount((count) => {
        return count + 1; a
    });
    setCount((count) => {
        return count + 1; b
    });
    setCount((count) => {
        return count + 1; c
    });
})
-->
