1.useEffect、useLayoutEffect、useInsertionEffect
触发时机不一样：
useEffect：是在依赖变化以后的当前 commit(commitWork)阶段完成以后异步执行，能拿到 dom 的引用
useEffect、useLayoutEffect、useInsertionEffect：是在依赖变化以后的当前 commit(commitWork)阶段一起同步执行，不能拿到 dom 的引用

2.fiber 上 flags 新增 PassiveEffect，代表当前 fiber 本次更新存在副作用(当前 fiber 更新时需要触发 effect)；
对于 effect hook，Passive 代表 useEffect 对应的 effect，因为还有 useLayoutEffect、useInsertionEffect
对于 effect hook，HookHasEffect 代表当前的 effect 本次更新存在副作用

3.Fiber 中 hook 的数据结构
对于函数组件，Fiber 的 memorizedState:hook 数据结构是一个单向链表，memorizedState 里面是 hook 的状态，比如 useState 就是对应 state，useEffect 对应的就是 useEffect 的数据结构,针对每一个 hook,hook 中的 memorizedState 存着每一个 hook 的自己的结构；譬如：useState 中 memorizedState 存的是初始值 0；useEffect 中 memorizedState 是{create,distory,deps,next}；useEffect 中 memorizedState 也是一个双向环状链表（a effect => b effect => a effect），为了方便遍历。

4.useEffect 中回调的执行过程
执行阶段：commit 阶段
执行时机：在 commit 前面，但是是通过宏任务(React 中 scheduler 包)异步执行的

5.为什么父有 useEffect，子有 useEffect，子的 useEffect 回调先执行，父的 useEffect 回调再执行？
commit 阶段(归阶段):从子到父收集 useEffect 的回调（这是一个双向链表），用了一个数组收集子到父的 useEffect [子 useEffect 双向环状链表,父 useEffect 双向环状链表]
我们需要收集两类的回调：
1.unmount 时执行的回调
2.update 时执行的回调
FiberRootNode.pendingPassiveEffects = {
//unmount: [],
//update: [],=> [子 useEffect 双向环状链表,父 useEffect 双向环状链表]
};

commit 阶段之后：useEffect 中回调的执行(宏任务)的时候，遍历数组 [子 useEffect 双向环状链表,父 useEffect 双向环状链表]，先执行子 useEffect 回调，再执行父 useEffect 回调。
遍历的整体流程是
(1).遍历 effect
(2).首先触发所有的 unmount effect 回调,而且对于某个 Fiber,如果触发了 unmount 的 destroy,本次更新不会再触发 update 的 create
(3).触发所有上次更新的 destroy
(4).触发所有这次更新的 create

<!--
function flushPassiveEffects(pendingPassiveEffects: PendingPassiveEffects) {
  //本次更新的任何create回调都必须在所有上一次更新的destory回调执行完后再执行
  // 遍历effect
  // debugger;
  let didFlushPassiveEffect = false;

  pendingPassiveEffects.unmount.forEach((effect) => {
    didFlushPassiveEffect = true;
    commitHookEffectListUnmount(Passive, effect);
  });
  pendingPassiveEffects.unmount = [];

  pendingPassiveEffects.update.forEach((effect) => {
    didFlushPassiveEffect = true;
    commitHookEffectListDestroy(Passive | HookHasEffect, effect);
  });
  pendingPassiveEffects.update.forEach((effect) => {
    didFlushPassiveEffect = true;
    commitHookEffectListCreate(Passive | HookHasEffect, effect);
  });
  pendingPassiveEffects.update = [];
  flushSyncCallbacks();
  return didFlushPassiveEffect;
}
-->

5.mount 和 update 时 useEffect 的区别
mount 时：一定将 Fiber 标记为 PassiveEffect
update 时:当 deps 变化时将 Fiber 标记为 PassiveEffect
deps 的比较是一个浅比较
