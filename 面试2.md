1.beginWork 递 (挂载)
建立节点的父子以及兄弟节点的关联关系 child return sibling
给 fiber 节点打上 flags 标记
<HostRoot>
<A>
<B/>
</A>
<HostRoot>
当进入 HostRoot 的 beginWork 时，通过对比 A currentFiberNode(挂载的时候是 null) 与 HostRoot 生成的 A reactElement, 生成 A 对应的 wip fiberNode
当进入 A 的 beginWork 时，通过对比 B currentFiberNode(挂载的时候是 null) 与 A 生成的 B reactElement, 生成 B 对应的 wip fiberNode

此过程最多会标记 2 类与结构变化相关的 flags，Placement(插入 a -> ab、移动 abc -> bca) ChildDeletion(删除 ul>li*3 -> ul>li*1)，不包括与属性相关的 flag Update(<img src='1'/> => <img src='2'/>)

1.1beginWork 性能优化策略

<div>
    <p>练习时长</p>
    <span>两年半</span>
</div>
理论上 mount 流程完毕后所包含的 flags:
两年半 Placement
span Placement
练习时长 Placement
p Placement
div Placement
相比于执行 5 次 Placement 我们可以构建好离屏的 dom 树后，对 div 执行 1 次 Placement 操作

2.completeWork 归 (挂载)
创建真实的 dom 节点，但是还没有渲染到页面中

<!--
针对如下的 dom 结构
const A = () => {
    return (
        <div>
            <B />
            <B />
        </div>
    );
};
const B = () => {
    return <div>1</div>;
};
*/ -->

归的时候去插入元素，遇到非 dom 的 fiberNode, 跳过向下遍历，直到找到 dom 就插入，遍历完回到最初的元素(最顶的元素)就跳出循环。
处理 flags，合并 subTreeFlag
bubbleProperties() 冒泡 subtreeFlags
寻找当前 fiberNode 下 子 fiberNode 的 flags 和 subsubTreeFlag, while 循环找 child，然后再找 sibling
建立真实 dom 的关系，把子 dom 插入到父 dom 中

3.commitWork(深度优先遍历)(挂载)
commitWork 利用 finishWork 指针，先递后归，递：直到找到 subTreeFlags:NoFlag(表示子节点没有变化)，就把 completeWork 生成的 dom 树插入到 div#root 中；
dom 树插入到 div#root 之后，FiberNode.flag 恢复为 0; 归：fiberRootNode.finishWork 此时指向刚刚生成的 Fiber 树

4.处理函数式组件在的 beginWork(递)过程(有 useState)：
//4.1.会有有三个变量：
let workInProgressHook: Hook | null = null; //当前正在处理的 hook
let currentHook: Hook | null = null; //当前在执行哪个 hook
let currentlyRenderingFiber: FiberNode | null = null; //当前在处理哪个函数组件
4.2 函数组件中调用 hook,怎么保证一定在函数内部调用 hook?
if(currentlyRenderingFiber === null){
//throw new Error("请在函数组件中调用 hook")
}
4.3App FiberNode(此时 currentlyRenderingFiber 指向 App FiberNode)中有一个 memorizeState 指向 当前正在执行的 hook(workInProgressHook),此时 hook 是一个链表结构
4.4 [state,dispatch] = usesState(1) ==> 源码会创建 state,dispatch 返回出去
