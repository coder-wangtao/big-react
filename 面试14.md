react 19
1.Actions(重要)
useTransition 中 startTransition 里 支持异步函数,这个异步函数就是 actions(useTransition 有个函数，不会阻塞 ui 渲染)
原先做网络请求是这样

  <!-- const [isPending, setIsPending] = useState(false);
  const handleSubmit = async () => {
    setIsPending(true);
    try {
      const res = await updateData(name);
    } catch (error) {
      setError(error.message);
    }
    setIsPending(false);
  }; -->

使用 Actions 后现在做网络请求是这样(react18 startTransition 里面是不支持异步函数的)

<!--
    const [isPending, startTransition] = useTransition();
    startTransition(
        //这个函数就叫做Actions
        async () => {
            try {
                const res = await updateDate(name);
            } catch (error) {
                setError(error.message);
            }
        }
    );
 -->

2.useActionState(重要)(表单提交 hook)
react 19 尝试弱化受控组件的概念

<!-- function App() {
  const [name, setName] = useState("");

  const updateData = (name) => {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve(name);
      }, 1000);
    });
  };

  const [state, handleSubmit, isPending] = useActionState(
    //这也是一个Actions
    async (prevState, name) => {
      try {
        const res = await updateData(name);
        return res;
      } catch (error) {
        return error.message;
      }
    },
    "初始化"
  );

  return (
    <div>
      <input
        value={name}
        onChange={(e) => {
          setName(e.target.value);
        }}
      />
      <button
        disabled={isPending}
        onClick={() => {
          startTransition(() => {
            //传入一个Actions
            handleSubmit(name);
          });
        }}
      >
        提交
      </button>
      <h1>{state}</h1>
    </div>
  );
}

export default App; -->

3.form 增强(form 的 action 可以传入一个 Actions)

4.useOptimistic：让你更乐观地更新用户界面,让你乐观的更新表单

5.useFormStatus(Form 中的 Context)
//父组件是一个表单，子组件想用表单的数据(想用父组件的状态) 不用直接通过 props 传递，子组件可以拿到父组件 Form 中 Actions 的数据(包括状态、数据、具体的 action、请求方法)。

6.use(不是一个 hooks,是一个 api,用于读取类似 Promise 或 Context 的值，可以在循环或者 if 语句中调用，必须在一个组件或者 hook 中调用 use)

7.React 19 移除 forwardRef，ref 可以直接通过 props 传递(React18 中 ref 是不允许作为 props 传递的,要用 forwardRef)

<!-- import React, { forwardRef, useRef } from 'react';

// 使用 forwardRef 包装函数组件
const Input = forwardRef((props, ref) => {
  return <input ref={ref} {...props} />;
});

const Parent = () => {
  const inputRef = useRef(null);

  const handleClick = () => {
    // 通过 ref 访问子组件中的 input 元素
    inputRef.current.focus();
  };

  return (
    <div>
      <Input ref={inputRef} />
      <button onClick={handleClick}>Focus Input</button>
    </div>
  );
};

export default Parent; -->

8.可以直接使用<Context/>,不需要再使用<Context.Provider/>了

9.ref 支持清理函数 return

10. useDeferredValue 增加初始值 initialValue(不是很重要)

11.支持文档元数据
在组件 jsx 中添加文档元数据，之前是不识别的，现在可以在组件 jsx 中将文档元数据插到 header 中

12.支持样式表
可以在组件 jsx 中引入样式表 precedence 表示顺序

<div>
      <link rel="stylesheet" href="/path/to/my/stylesheet.css" precedence="default"/>
      <link rel="stylesheet" href="/path/to/my/stylesheet.css" precedence="high"/>
</div>

13.jsx 支持异步脚本
可以在组件 jsx 中引入 script 标签(多次引入会去重)

<div>
  <script async={true} src="/path/to/my/stylesheet.css"/>
  <script async={true} src="/path/to/my/stylesheet.css"/>
</div>
