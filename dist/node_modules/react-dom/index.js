(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react'), require('scheduler')) :
  typeof define === 'function' && define.amd ? define(['react', 'scheduler'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ReactDOM = factory(global.React, global.scheduler));
})(this, (function (React, scheduler) { 'use strict';

  function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n.default = e;
    return Object.freeze(n);
  }

  var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);

  const NoFlags = 0b00000000000000000000000000;
  const Placement = 0b00000000000000000000000010;
  const Update = 0b00000000000000000000000100;
  const ChildDeletion = 0b00000000000000000000010000;
  const PassiveEffect = 0b0001000;
  const MutationMask = Placement | Update | ChildDeletion;
  const PassiveMask = PassiveEffect | ChildDeletion;

  const FunctionComponent = 0;
  const HostRoot = 3;
  const HostComponent = 5;
  // <div>123</div>
  const HostText = 6;
  const Fragment = 7;

  // import ReactCurrentBatchConfig from "react/src/currentBatchConfig";
  // import {
  //   unstable_getCurrentPriorityLevel,
  //   unstable_IdlePriority,
  //   unstable_ImmediatePriority,
  //   unstable_NormalPriority,
  //   unstable_UserBlockingPriority,
  // } from "scheduler";
  // import { FiberRootNode } from "./fiber";
  const SyncLane = 0b00001;
  const NoLane = 0b00000;
  const NoLanes = 0b00000;
  function mergeLanes(laneA, laneB) {
      return laneA | laneB;
  }
  function requestUpdateLane() {
      //   const isTransition = ReactCurrentBatchConfig.transition !== null;
      //   if (isTransition) {
      //     return TransitionLane;
      //   }
      //   // 从上下文环境中获取Scheduler优先级
      //   const currentSchedulerPriority = unstable_getCurrentPriorityLevel();
      //   const lane = schedulerPriorityToLane(currentSchedulerPriority);
      //   return lane;
      return SyncLane;
  }
  function getHighestPriorityLane(lanes) {
      return lanes & -lanes;
  }
  // export function isSubsetOfLanes(set: Lanes, subset: Lane) {
  // 	return (set & subset) === subset;
  // }
  function markRootFinished(root, lane) {
      root.pendingLanes &= ~lane;
      // root.suspendedLanes = NoLanes;
      // root.pingedLanes = NoLanes;
  }
  // export function lanesToSchedulerPriority(lanes: Lanes) {
  // 	const lane = getHighestPriorityLane(lanes);
  // 	if (lane === SyncLane) {
  // 		return unstable_ImmediatePriority;
  // 	}
  // 	if (lane === InputContinuousLane) {
  // 		return unstable_UserBlockingPriority;
  // 	}
  // 	if (lane === DefaultLane) {
  // 		return unstable_NormalPriority;
  // 	}
  // 	return unstable_IdlePriority;
  // }
  // export function schedulerPriorityToLane(schedulerPriority: number): Lane {
  // 	if (schedulerPriority === unstable_ImmediatePriority) {
  // 		return SyncLane;
  // 	}
  // 	if (schedulerPriority === unstable_UserBlockingPriority) {
  // 		return InputContinuousLane;
  // 	}
  // 	if (schedulerPriority === unstable_NormalPriority) {
  // 		return DefaultLane;
  // 	}
  // 	return NoLane;
  // }
  // export function markRootPinged(root: FiberRootNode, pingedLane: Lane) {
  // 	root.pingedLanes |= root.suspendedLanes & pingedLane;
  // }
  // export function markRootSuspended(root: FiberRootNode, suspendedLane: Lane) {
  // 	root.suspendedLanes |= suspendedLane;
  // 	root.pingedLanes &= ~suspendedLane;
  // }
  // export function getNextLane(root: FiberRootNode): Lane {
  // 	const pendingLanes = root.pendingLanes;
  // 	if (pendingLanes === NoLanes) {
  // 		return NoLane;
  // 	}
  // 	let nextLane = NoLane;
  // 	// 排除掉挂起的lane
  // 	const suspendedLanes = pendingLanes & ~root.suspendedLanes;
  // 	if (suspendedLanes !== NoLanes) {
  // 		nextLane = getHighestPriorityLane(suspendedLanes);
  // 	} else {
  // 		const pingedLanes = pendingLanes & root.pingedLanes;
  // 		if (pingedLanes !== NoLanes) {
  // 			nextLane = getHighestPriorityLane(pingedLanes);
  // 		}
  // 	}
  // 	return nextLane;
  // }
  // export function includeSomeLanes(set: Lanes, subset: Lane | Lanes): boolean {
  // 	return (set & subset) !== NoLanes;
  // }
  // export function removeLanes(set: Lanes, subet: Lanes | Lane): Lanes {
  // 	return set & ~subet;
  // }

  class FiberNode {
      pendingProps;
      memoizedProps;
      key;
      stateNode;
      type;
      ref;
      tag;
      flags;
      subtreeFlags;
      deletions;
      return;
      sibling;
      child;
      index;
      updateQueue;
      memoizedState;
      alternate;
      constructor(tag, pendingProps, key) {
          // 实例
          this.tag = tag;
          this.key = key || null;
          this.stateNode = null;
          this.type = null;
          // 树结构
          this.return = null;
          this.sibling = null;
          this.child = null;
          this.index = 0;
          this.ref = null;
          // 状态
          this.memoizedState = null; //memoizedState对于 函数组件（App）根节点，就是hook链表
          this.pendingProps = pendingProps; //pendingProps对于文本节点里面是{content:"1111"}  对于div等节点就是jsx props {children:,...} / diff过程中老的jsx
          this.memoizedProps = null; //pendingProps对于文本节点里面是{content:"1111"}  对于div等节点就是jsx props {children:,...}  beginWork执行后赋值 / diff过程中新的jsx
          this.updateQueue = null;
          // 副作用
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
          this.deletions = null;
          // 调度
          // this.lanes = NoLanes;
          // this.childLanes = NoLanes;
          this.alternate = null;
      }
  }
  class FiberRootNode {
      container;
      current;
      finishedWork;
      pendingLanes;
      finishLane;
      pendingPassiveEffects;
      constructor(container, hostRootFiber) {
          this.container = container;
          this.current = hostRootFiber;
          hostRootFiber.stateNode = this;
          this.finishedWork = null;
          this.pendingLanes = NoLanes;
          this.finishLane = NoLane;
          this.pendingPassiveEffects = {
              unmount: [],
              update: [],
          };
      }
  }
  function createFiberFromElement(element) {
      const { type, key, props } = element;
      let fiberTag = FunctionComponent;
      if (typeof type === "string") {
          fiberTag = HostComponent;
      }
      else if (typeof type !== "function") {
          console.error("未定义的type类型", element);
      }
      const fiber = new FiberNode(fiberTag, props, key);
      fiber.type = type;
      return fiber;
  }
  function createFiberFromFragment(elements, key) {
      const fiber = new FiberNode(Fragment, elements, key);
      return fiber;
  }
  const createWorkInProgress = (current, pendingProps) => {
      let wip = current.alternate;
      if (wip === null) {
          // mount
          wip = new FiberNode(current.tag, pendingProps, current.key);
          wip.type = current.type;
          wip.stateNode = current.stateNode;
          wip.alternate = current;
          current.alternate = wip;
      }
      else {
          // update
          wip.pendingProps = pendingProps;
          wip.flags = NoFlags;
          wip.subtreeFlags = NoFlags;
          wip.deletions = null;
          wip.type = current.type;
      }
      wip.updateQueue = current.updateQueue;
      wip.flags = current.flags;
      wip.child = current.child;
      // 数据
      wip.memoizedProps = current.memoizedProps;
      wip.memoizedState = current.memoizedState;
      return wip;
  };

  const supportSymbol = typeof Symbol === "function" && Symbol.for;
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for("react.element")
      : 0xeac7;
  const REACT_FRAGMENT_TYPE = supportSymbol
      ? Symbol.for("react.fragment")
      : 0xeaca;

  function ChildReconciler(shouldTrackEffects) {
      function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackEffects) {
              return;
          }
          const deletions = returnFiber.deletions;
          if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
          }
          else {
              deletions.push(childToDelete);
          }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackEffects) {
              return;
          }
          let childToDelete = currentFirstChild;
          while (childToDelete !== null) {
              deleteChild(returnFiber, childToDelete);
              childToDelete = childToDelete.sibling;
          }
      }
      function reconcileSingleElement(returnFiber, currentFirstChild, element) {
          // 前：abc 后：a  删除bc
          // 前：a 后：b 删除b、创建a
          // 前：无 后：a 创建a
          const key = element.key;
          let current = currentFirstChild;
          while (current !== null) {
              if (current.key === key) {
                  // key相同，比较type
                  if (element.$$typeof === REACT_ELEMENT_TYPE) {
                      if (current.type === element.type) {
                          let props = element.props;
                          if (element.type === REACT_FRAGMENT_TYPE) {
                              props = element.props.children;
                          }
                          // type相同 可以复用
                          const existing = useFiber(current, props);
                          existing.return = returnFiber;
                          // 当前节点可复用，其他兄弟节点都删除
                          deleteRemainingChildren(returnFiber, current.sibling);
                          return existing;
                      }
                      // key相同但type不同，没法复用。后面的兄弟节点也没有复用的可能性了，都删除
                      deleteRemainingChildren(returnFiber, current);
                      break;
                  }
                  else {
                      console.error("未定义的element.$$typeof", element.$$typeof);
                      break;
                  }
              }
              else {
                  // key不同，删除旧的，继续比较
                  deleteChild(returnFiber, current);
                  current = current.sibling;
              }
          }
          // 创建新的
          let fiber;
          if (element.type === REACT_FRAGMENT_TYPE) {
              fiber = createFiberFromFragment(element.props.children, key);
          }
          else {
              fiber = createFiberFromElement(element);
          }
          fiber.return = returnFiber;
          return fiber;
      }
      function placeSingleChild(fiber) {
          if (shouldTrackEffects && fiber.alternate === null) {
              fiber.flags |= Placement;
          }
          return fiber;
      }
      function updateFromMap(returnFiber, existingChildren, index, element) {
          let keyToUse;
          if (typeof element === "string") {
              keyToUse = index;
          }
          else {
              keyToUse = element.key !== null ? element.key : index;
          }
          //老节点的fiber
          const before = existingChildren.get(keyToUse);
          //文本节点
          if (typeof element === "string") {
              if (before) {
                  // fiber key相同，如果type也相同，则可复用
                  existingChildren.delete(keyToUse);
                  if (before.tag === HostText) {
                      // 复用文本节点
                      return useFiber(before, { content: element });
                  }
                  else {
                      deleteChild(returnFiber, before);
                  }
              }
              // 新建文本节点
              return new FiberNode(HostText, { content: element }, null);
          }
          //div
          if (typeof element === "object" && element !== null) {
              switch (element.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      if (element.type === REACT_FRAGMENT_TYPE) {
                          return updateFragment$1(returnFiber, before, element, keyToUse, existingChildren);
                      }
                      // before 老节点的fiber
                      if (before) {
                          // fiber key相同，如果type也相同，则可复用
                          //从map中删除代表可以复用
                          //剩下的最后都会被移除
                          //1 2 3 老
                          //2 3 1 新
                          existingChildren.delete(keyToUse);
                          if (before.type === element.type) {
                              // 复用
                              return useFiber(before, element.props);
                          }
                          else {
                              deleteChild(returnFiber, before);
                          }
                      }
                      return createFiberFromElement(element);
              }
          }
          if (Array.isArray(element)) {
              return updateFragment$1(returnFiber, before, element, keyToUse, existingChildren);
          }
          console.error("updateFromMap未处理的情况", before, element);
          return null;
      }
      function reconcileSingleTextNode(returnFiber, currentFirstChild, content) {
          // 前：b 后：a
          // TODO 前：abc 后：a
          // TODO 前：bca 后：a
          let current = currentFirstChild;
          while (current !== null) {
              if (current.tag === HostText) {
                  // 可以复用
                  const existing = useFiber(current, { content });
                  existing.return = returnFiber;
                  deleteRemainingChildren(returnFiber, current.sibling);
                  return existing;
              }
              // 不能复用
              deleteChild(returnFiber, current);
              current = current.sibling;
          }
          const created = new FiberNode(HostText, { content }, null);
          created.return = returnFiber;
          return created;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChild) {
          // 遍历到的最后一个可复用fiber在before中的index
          let lastPlacedIndex = 0;
          // 创建的最后一个fiber
          let lastNewFiber = null;
          // 创建的第一个fiber
          let firstNewFiber = null;
          // 遍历前的准备工作，将current保存在map中
          const existingChildren = new Map();
          let current = currentFirstChild;
          while (current !== null) {
              const keyToUse = current.key !== null ? current.key : current.index;
              existingChildren.set(keyToUse, current);
              current = current.sibling;
          }
          // 遍历流程
          for (let i = 0; i < newChild.length; i++) {
              const after = newChild[i];
              // after对应的fiber，可能来自于复用，也可能是新建
              const newFiber = updateFromMap(returnFiber, existingChildren, i, after);
              newFiber.index = i;
              newFiber.return = returnFiber;
              if (lastNewFiber === null) {
                  lastNewFiber = firstNewFiber = newFiber;
              }
              else {
                  lastNewFiber = lastNewFiber.sibling = newFiber;
              }
              if (!shouldTrackEffects) {
                  continue;
              }
              const current = newFiber.alternate;
              if (current !== null) {
                  const oldIndex = current.index;
                  if (oldIndex < lastPlacedIndex) {
                      // 移动
                      newFiber.flags |= Placement;
                      continue;
                  }
                  else {
                      // 不移动
                      lastPlacedIndex = oldIndex;
                  }
              }
              else {
                  // fiber不能复用，插入新节点
                  newFiber.flags |= Placement;
              }
          }
          // 遍历后的收尾工作，标记existingChildren中剩余的删除
          existingChildren.forEach((fiber) => {
              deleteChild(returnFiber, fiber);
          });
          return firstNewFiber;
      }
      function reconcileChildFibers(returnFiber, currentFirstChild, newChild) {
          // 判断Fragment
          const isUnkeyedTopLevelFragment = typeof newChild === "object" &&
              newChild !== null &&
              newChild.type === REACT_FRAGMENT_TYPE &&
              newChild.key === null;
          if (isUnkeyedTopLevelFragment) {
              newChild = newChild.props.children; //直接赋值children
          }
          // newChild 为 JSX
          // currentFirstChild 为 fiberNode
          if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                  //children为单节点
                  case REACT_ELEMENT_TYPE:
                      return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild));
              }
              //children为多个
              if (Array.isArray(newChild)) {
                  return reconcileChildrenArray(returnFiber, currentFirstChild, newChild);
              }
          }
          if (typeof newChild === "string" || typeof newChild === "number") {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, newChild + ""));
          }
          console.error("reconcile时未实现的child 类型", newChild, currentFirstChild);
          return null;
      }
      return reconcileChildFibers;
  }
  function useFiber(fiber, pendingProps) {
      const clone = createWorkInProgress(fiber, pendingProps);
      clone.index = 0;
      clone.sibling = null;
      return clone;
  }
  function updateFragment$1(returnFiber, current, elements, key, existingChildren) {
      let fiber;
      if (!current || current.tag !== Fragment) {
          fiber = createFiberFromFragment(elements, key);
      }
      else {
          existingChildren.delete(key);
          fiber = useFiber(current, elements);
      }
      fiber.return = returnFiber;
      return fiber;
  }
  const reconcileChildFibers = ChildReconciler(true);
  const mountChildFibers = ChildReconciler(false);

  const internals = React__namespace.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  // 创建
  const createUpdate = (action, lane) => {
      return {
          action,
          lane,
          next: null,
      };
  };
  // 插入
  const enqueueUpdate = (updateQueue, update) => {
      const pending = updateQueue.shared.pending;
      if (pending === null) {
          update.next = update; //先不管
      }
      else {
          update.next = pending.next;
          pending.next = update;
      }
      updateQueue.shared.pending = update;
  };
  // 初始化
  const createUpdateQueue = () => {
      const updateQueue = {
          shared: {
              pending: null,
          },
          dispatch: null,
      };
      return updateQueue;
  };
  // 消费
  const processUpdateQueue = (baseState, pendingUpdate, renderLane, onSkipUpdate) => {
      const result = {
          memoizedState: baseState,
          baseState,
          baseQueue: null,
      };
      if (pendingUpdate !== null) {
          // 第一个update
          const first = pendingUpdate.next;
          let pending = pendingUpdate.next;
          do {
              const updateLane = pending.lane;
              if (updateLane === renderLane) {
                  const action = pending.action;
                  if (action instanceof Function) {
                      baseState = action(baseState);
                  }
                  else {
                      baseState = action;
                  }
              }
              else {
                  {
                      console.warn("不应该进入");
                  }
              }
              pending = pending.next;
          } while (pending !== first);
      }
      result.memoizedState = baseState;
      return result;
  };

  const Passive = 0b0010;
  const HookHasEffect = 0b0001;

  let workInProgressHook = null;
  let currentHook = null; //当前在执行哪个hook
  let currentlyRenderingFiber = null; //当前在处理哪个函数组件
  let renderLane = NoFlags;
  const { currentDispatcher } = internals;
  const renderWithHooks = (workInProgress, lane) => {
      currentlyRenderingFiber = workInProgress;
      // 重置
      workInProgress.memoizedState = null;
      renderLane = lane;
      workInProgress.updateQueue = null;
      const current = workInProgress.alternate;
      if (current !== null) {
          currentDispatcher.current = HooksDispatcherOnUpdate;
      }
      else {
          currentDispatcher.current = HooksDispatcherOnMount;
      }
      const Component = workInProgress.type;
      const props = workInProgress.pendingProps;
      const children = Component(props);
      // 重置
      currentlyRenderingFiber = null;
      workInProgressHook = null;
      currentHook = null;
      renderLane = NoLane;
      return children;
  };
  const HooksDispatcherOnMount = {
      useState: mountState,
      useEffect: mountEffect,
  };
  const HooksDispatcherOnUpdate = {
      useState: updateState,
      useEffect: updateEffect,
  };
  function mountState(initialState) {
      const hook = mountWorkInProgressHook();
      let memoizedState;
      if (initialState instanceof Function) {
          memoizedState = initialState();
      }
      else {
          memoizedState = initialState;
      }
      hook.memoizedState = memoizedState;
      const queue = createUpdateQueue();
      hook.updateQueue = queue;
      // @ts-ignore
      const dispatch = (queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue));
      return [memoizedState, dispatch];
  }
  function updateState() {
      const hook = updateWorkInProgressHook();
      const queue = hook.updateQueue;
      hook.memoizedState;
      const pending = queue.shared.pending;
      // 缺少render阶段更新的处理逻辑
      queue.shared.pending = null;
      if (pending !== null) {
          const { memoizedState } = processUpdateQueue(hook.memoizedState, pending, renderLane);
          hook.memoizedState = memoizedState;
      }
      return [hook.memoizedState, queue.dispatch];
  }
  function mountEffect(create, deps) {
      const hook = mountWorkInProgressHook();
      const nextDeps = deps === undefined ? null : deps;
      currentlyRenderingFiber.flags |= PassiveEffect;
      hook.memoizedState = pushEffect(Passive | HookHasEffect, create, undefined, nextDeps);
  }
  function updateEffect(create, deps) {
      const hook = updateWorkInProgressHook();
      const nextDeps = deps === undefined ? null : deps;
      let destroy;
      if (currentHook !== null) {
          const prevEffect = currentHook.memoizedState;
          destroy = prevEffect.destroy;
          if (nextDeps !== null) {
              // 浅比较依赖
              const prevDeps = prevEffect.deps;
              if (areHookInputsEqual(nextDeps, prevDeps)) {
                  hook.memoizedState = pushEffect(Passive, create, destroy, nextDeps);
                  return;
              }
          }
          // 浅比较 不相等
          currentlyRenderingFiber.flags |= PassiveEffect;
          hook.memoizedState = pushEffect(Passive | HookHasEffect, create, destroy, nextDeps);
      }
  }
  function areHookInputsEqual(nextDeps, prevDeps) {
      if (prevDeps === null || nextDeps === null) {
          return false;
      }
      for (let i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
          if (Object.is(prevDeps[i], nextDeps[i])) {
              continue;
          }
          return false;
      }
      return true;
  }
  function pushEffect(hookFlags, create, destroy, deps) {
      const effect = {
          tag: hookFlags,
          create,
          destroy,
          deps,
          next: null,
      };
      const fiber = currentlyRenderingFiber;
      const updateQueue = fiber.updateQueue;
      if (updateQueue === null) {
          const updateQueue = createFCUpdateQueue();
          fiber.updateQueue = updateQueue;
          effect.next = effect;
          updateQueue.lastEffect = effect;
      }
      else {
          // 插入effect
          const lastEffect = updateQueue.lastEffect;
          if (lastEffect === null) {
              effect.next = effect;
              updateQueue.lastEffect = effect;
          }
          else {
              const firstEffect = lastEffect.next;
              lastEffect.next = effect;
              effect.next = firstEffect;
              updateQueue.lastEffect = effect;
          }
      }
      return effect;
  }
  function createFCUpdateQueue() {
      const updateQueue = createUpdateQueue();
      updateQueue.lastEffect = null;
      return updateQueue;
  }
  function dispatchSetState(fiber, updateQueue, action) {
      const lane = requestUpdateLane();
      const update = createUpdate(action, lane);
      enqueueUpdate(updateQueue, update);
      scheduleUpdateOnFiber(fiber, lane);
  }
  function mountWorkInProgressHook() {
      const hook = {
          memoizedState: null,
          updateQueue: null,
          next: null,
      };
      //当前在处理的Hook
      if (workInProgressHook === null) {
          //mount
          if (currentlyRenderingFiber === null) {
              //在函数式组件中调用hook,怎么保证一定在函数内调用hook
              console.error("mountWorkInprogressHook时currentlyRenderingFiber未定义");
          }
          else {
              currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
          }
      }
      else {
          workInProgressHook = workInProgressHook.next = hook;
      }
      return workInProgressHook;
  }
  function updateWorkInProgressHook() {
      // 情况1:交互触发的更新，此时wipHook还不存在，复用 currentHook链表中对应的 hook 克隆 wipHook
      // 情况2:render阶段触发的更新，wipHook已经存在，使用wipHook
      let nextCurrentHook;
      let nextWorkInProgressHook;
      if (currentHook === null) {
          // 情况1 当前组件的第一个hook
          const current = currentlyRenderingFiber.alternate;
          if (current !== null) {
              nextCurrentHook = current.memoizedState;
          }
          else {
              nextCurrentHook = null;
          }
      }
      else {
          nextCurrentHook = currentHook.next;
      }
      if (workInProgressHook === null) {
          // 情况2 当前组件的第一个hook
          nextWorkInProgressHook = currentlyRenderingFiber
              .memoizedState;
      }
      else {
          nextWorkInProgressHook = workInProgressHook.next;
      }
      if (nextWorkInProgressHook !== null) {
          // 针对情况2 nextWorkInProgressHook保存了当前hook的数据
          workInProgressHook = nextWorkInProgressHook;
          currentHook = nextCurrentHook;
      }
      else {
          // 针对情况1 nextCurrentHook保存了可供克隆的hook数据
          if (nextCurrentHook === null) {
              // 本次render当前组件执行的hook比之前多，举个例子：
              // 之前：hook1 -> hook2 -> hook3
              // 本次：hook1 -> hook2 -> hook3 -> hook4
              // 那到了hook4，nextCurrentHook就为null
              console.error(`组件${currentlyRenderingFiber?.type}本次执行的hook比上次多`);
          }
          currentHook = nextCurrentHook;
          const newHook = {
              memoizedState: currentHook.memoizedState,
              // 对于state，保存update相关数据
              updateQueue: currentHook.updateQueue,
              next: null,
          };
          if (workInProgressHook === null) {
              currentlyRenderingFiber.memoizedState =
                  workInProgressHook = newHook;
          }
          else {
              workInProgressHook = workInProgressHook.next = newHook;
          }
      }
      return workInProgressHook;
  }

  const beginWork = (workInProgress, renderLane) => {
      switch (workInProgress.tag) {
          case HostRoot:
              return updateHostRoot(workInProgress, renderLane);
          case HostComponent:
              return updateHostComponent(workInProgress);
          case HostText:
              return null;
          case FunctionComponent:
              return updateFunctionComponent(workInProgress, renderLane);
          case Fragment:
              return updateFragment(workInProgress);
          default:
              console.error("beginWork未处理的情况");
              return null;
      }
  };
  function updateFragment(wip) {
      const nextChildren = wip.pendingProps;
      reconcileChildren(wip, nextChildren);
      return wip.child;
  }
  function updateFunctionComponent(workInProgress, renderLane) {
      const nextChildren = renderWithHooks(workInProgress, renderLane);
      reconcileChildren(workInProgress, nextChildren);
      return workInProgress.child;
  }
  function updateHostComponent(workInProgress) {
      // 根据element创建fiberNode
      const nextProps = workInProgress.pendingProps;
      const nextChildren = nextProps.children;
      reconcileChildren(workInProgress, nextChildren);
      return workInProgress.child;
  }
  function updateHostRoot(workInProgress, renderLane) {
      const baseState = workInProgress.memoizedState;
      const updateQueue = workInProgress.updateQueue;
      const pending = updateQueue.shared.pending;
      updateQueue.shared.pending = null;
      const { memoizedState } = processUpdateQueue(baseState, pending, renderLane);
      workInProgress.memoizedState = memoizedState;
      const nextChildren = workInProgress.memoizedState;
      reconcileChildren(workInProgress, nextChildren);
      return workInProgress.child;
  }
  function reconcileChildren(workInProgress, children) {
      const current = workInProgress.alternate;
      if (current !== null) {
          // update
          workInProgress.child = reconcileChildFibers(workInProgress, current.child, children);
      }
      else {
          // mount
          workInProgress.child = mountChildFibers(workInProgress, null, children);
      }
  }

  // 支持的事件类型
  const validEventTypeList = ["click"];
  const elementEventPropsKey = "__props";
  function createSyntheticEvent(e) {
      const syntheticEvent = e;
      syntheticEvent.__stopPropagation = false;
      const originStopPropagation = e.stopPropagation;
      syntheticEvent.stopPropagation = () => {
          syntheticEvent.__stopPropagation = true;
          if (originStopPropagation) {
              originStopPropagation();
          }
      };
      return syntheticEvent;
  }
  function getEventCallbackNameFromtEventType(eventType) {
      return {
          click: ["onClickCapture", "onClick"],
      }[eventType];
  }
  // 将支持的事件回调保存在DOM中
  const updateFiberProps = (node, props) => {
      node[elementEventPropsKey] =
          node[elementEventPropsKey] || {};
      validEventTypeList.forEach((eventType) => {
          const callbackNameList = getEventCallbackNameFromtEventType(eventType);
          if (!callbackNameList) {
              return;
          }
          callbackNameList.forEach((callbackName) => {
              if (Object.hasOwnProperty.call(props, callbackName)) {
                  node[elementEventPropsKey][callbackName] =
                      props[callbackName];
              }
          });
      });
      return node;
  };
  const triggerEventFlow = (paths, se) => {
      for (let i = 0; i < paths.length; i++) {
          const callback = paths[i];
          callback.call(null, se);
          if (se.__stopPropagation) {
              break;
          }
      }
  };
  const dispatchEvent = (container, eventType, e) => {
      const targetElement = e.target;
      if (targetElement === null) {
          console.error("事件不存在target", e);
          return;
      }
      const { capture, bubble } = collectPaths(targetElement, container, eventType);
      const se = createSyntheticEvent(e);
      triggerEventFlow(capture, se);
      if (!se.__stopPropagation) {
          triggerEventFlow(bubble, se);
      }
  };
  // 收集从目标元素到HostRoot之间所有目标回调函数
  const collectPaths = (targetElement, container, eventType) => {
      const paths = {
          capture: [],
          bubble: [],
      };
      // 收集事件回调是冒泡的顺序
      while (targetElement && targetElement !== container) {
          const eventProps = targetElement[elementEventPropsKey];
          if (eventProps) {
              const callbackNameList = getEventCallbackNameFromtEventType(eventType);
              if (callbackNameList) {
                  callbackNameList.forEach((callbackName, i) => {
                      const eventCallback = eventProps[callbackName];
                      if (eventCallback) {
                          if (i === 0) {
                              // 反向插入捕获阶段的事件回调
                              paths.capture.unshift(eventCallback);
                          }
                          else {
                              // 正向插入冒泡阶段的事件回调
                              paths.bubble.push(eventCallback);
                          }
                      }
                  });
              }
          }
          targetElement = targetElement.parentNode;
      }
      return paths;
  };
  const initEvent = (container, eventType) => {
      if (!validEventTypeList.includes(eventType)) {
          console.error("当前不支持", eventType, "事件");
          return;
      }
      container.addEventListener(eventType, (e) => {
          dispatchEvent(container, eventType, e);
      });
  };

  const createInstance = (type, props) => {
      const element = document.createElement(type);
      return updateFiberProps(element, props);
  };
  const createTextInstance = (content) => {
      return document.createTextNode(content);
  };
  const appendInitialChild = (parent, child) => {
      parent.appendChild(child);
  };
  const appendChildToContainer = (child, container) => {
      // appendChild 会把指定的节点移动到父元素的最后，即使该节点已经存在于 DOM 中，
      // appendChild 也会把它从原位置移除，并重新添加到最后的位置。
      // debugger;
      container.appendChild(child);
  };
  const insertChildToContainer = (child, container, before) => {
      container.insertBefore(before, child);
  };
  const removeChild = (child, container) => {
      container.removeChild(child);
  };
  const commitTextUpdate = (textIntance, content) => {
      textIntance.nodeValue = content;
  };

  let nextEffect = null;
  // 以DFS形式执行
  const commitMutationEffects = (finishedWork, root) => {
      nextEffect = finishedWork;
      while (nextEffect !== null) {
          // 向下遍历
          const child = nextEffect.child;
          if ((nextEffect.subtreeFlags & (MutationMask | PassiveMask)) !== NoFlags &&
              child !== null) {
              nextEffect = child;
          }
          else {
              // 向上遍历
              up: while (nextEffect !== null) {
                  commitMutationEffectsOnFiber(nextEffect, root);
                  const sibling = nextEffect.sibling;
                  if (sibling !== null) {
                      nextEffect = sibling;
                      break up;
                  }
                  nextEffect = nextEffect.return;
              }
          }
      }
  };
  const commitMutationEffectsOnFiber = (finishedWork, root) => {
      const flags = finishedWork.flags;
      if ((flags & Placement) !== NoFlags) {
          // 插入/移动
          commitPlacement(finishedWork);
          finishedWork.flags &= -3;
      }
      if ((flags & ChildDeletion) !== NoFlags) {
          const deletions = finishedWork.deletions;
          if (deletions !== null) {
              deletions.forEach((childToDelete) => {
                  commitDeletion(childToDelete, root);
              });
          }
          finishedWork.flags &= -17;
      }
      if ((flags & Update) !== NoFlags) {
          commitUpdate(finishedWork);
          finishedWork.flags &= -5;
      }
      if ((flags & PassiveEffect) !== NoFlags) {
          // 收集回调
          commitPassiveEffect(finishedWork, root, "update");
          finishedWork.flags &= -9;
      }
  };
  function commitPassiveEffect(fiber, root, type) {
      // update unmount
      if (fiber.tag !== FunctionComponent ||
          (type === "update" && (fiber.flags & PassiveEffect) === NoFlags)) {
          return;
      }
      const updateQueue = fiber.updateQueue;
      if (updateQueue !== null) {
          if (updateQueue.lastEffect === null && true) {
              console.error("当FC存在PassiveEffect flag时，不应该不存在effect");
          }
          root.pendingPassiveEffects[type].push(updateQueue.lastEffect);
      }
  }
  /**
   * 难点在于目标fiber的hostSibling可能并不是他的同级sibling
   * 比如： <A/><B/> 其中：function B() {return <div/>} 所以A的hostSibling实际是B的child
   * 实际情况层级可能更深
   * 同时：一个fiber被标记Placement，那他就是不稳定的（他对应的DOM在本次commit阶段会移动），也不能作为hostSibling
   */
  function gethostSibling(fiber) {
      let node = fiber;
      findSibling: while (true) {
          while (node.sibling === null) {
              // 如果当前节点没有sibling，则找他父级sibling
              const parent = node.return;
              if (parent === null ||
                  parent.tag === HostComponent ||
                  parent.tag === HostRoot) {
                  // 没找到
                  return null;
              }
              node = parent;
          }
          node.sibling.return = node.return;
          // 向同级sibling寻找
          node = node.sibling;
          while (node.tag !== HostText && node.tag !== HostComponent) {
              // 找到一个非Host fiber，向下找，直到找到第一个Host子孙
              if ((node.flags & Placement) !== NoFlags) {
                  // 这个fiber不稳定，不能用
                  continue findSibling;
              }
              if (node.child === null) {
                  continue findSibling;
              }
              else {
                  node.child.return = node;
                  node = node.child;
              }
          }
          // 找到最有可能的fiber
          if ((node.flags & Placement) === NoFlags) {
              // 这是稳定的fiber，就他了
              return node.stateNode;
          }
      }
  }
  const commitPlacement = (finishedWork) => {
      const hostParent = getHostParent(finishedWork);
      const sibling = gethostSibling(finishedWork);
      // appendChild / insertBefore
      insertOrAppendPlacementNodeIntoContainer(finishedWork, hostParent, sibling);
  };
  function commitUpdate(finishedWork) {
      switch (finishedWork.tag) {
          case HostText:
              const newContent = finishedWork.pendingProps.content;
              return commitTextUpdate(finishedWork.stateNode, newContent);
          case HostComponent:
              return updateFiberProps(finishedWork.stateNode, finishedWork.memoizedProps);
      }
      console.error("commitUpdate未支持的类型", finishedWork);
  }
  function insertOrAppendPlacementNodeIntoContainer(fiber, parent, before) {
      if (fiber.tag === HostComponent || fiber.tag === HostText) {
          if (before) {
              insertChildToContainer(fiber.stateNode, parent, before);
          }
          else {
              appendChildToContainer(fiber.stateNode, parent);
          }
          return;
      }
      const child = fiber.child;
      if (child !== null) {
          insertOrAppendPlacementNodeIntoContainer(child, parent, before);
          let sibling = child.sibling;
          while (sibling !== null) {
              insertOrAppendPlacementNodeIntoContainer(sibling, parent, before);
              sibling = sibling.sibling;
          }
      }
  }
  function getHostParent(fiber) {
      let parent = fiber.return;
      while (parent) {
          const parentTag = parent.tag;
          if (parentTag === HostComponent) {
              return parent.stateNode;
          }
          if (parentTag === HostRoot) {
              return parent.stateNode.container;
          }
          parent = parent.return;
      }
      console.error("getHostParent未找到hostParent");
  }
  function commitHookEffectList(flags, lastEffect, callback) {
      let effect = lastEffect.next;
      do {
          if ((effect.tag & flags) === flags) {
              callback(effect);
          }
          effect = effect.next;
      } while (effect !== lastEffect.next);
  }
  function commitHookEffectListUnmount(flags, lastEffect) {
      commitHookEffectList(flags, lastEffect, (effect) => {
          const destroy = effect.destroy;
          if (typeof destroy === "function") {
              destroy();
          }
          effect.tag &= -2;
      });
  }
  function commitHookEffectListDestroy(flags, lastEffect) {
      commitHookEffectList(flags, lastEffect, (effect) => {
          const destroy = effect.destroy;
          if (typeof destroy === "function") {
              destroy();
          }
      });
  }
  function commitHookEffectListCreate(flags, lastEffect) {
      commitHookEffectList(flags, lastEffect, (effect) => {
          const create = effect.create;
          if (typeof create === "function") {
              effect.destroy = create();
          }
      });
  }
  function recordHostChildrenToDelete(childrenToDelete, unmountFiber) {
      // 1. 找到第一个root host节点
      const lastOne = childrenToDelete[childrenToDelete.length - 1];
      if (!lastOne) {
          childrenToDelete.push(unmountFiber);
      }
      else {
          let node = lastOne.sibling;
          while (node !== null) {
              if (unmountFiber === node) {
                  childrenToDelete.push(unmountFiber);
              }
              node = node.sibling;
          }
      }
      // 2. 每找到一个 host节点，判断下这个节点是不是 1 找到那个节点的兄弟节点
  }
  /**
   * 删除需要考虑：
   * HostComponent：需要遍历他的子树，为后续解绑ref创造条件，HostComponent本身只需删除最上层节点即可
   * FunctionComponent：effect相关hook的执行，并遍历子树
   */
  function commitDeletion(childToDelete, root) {
      const rootChildrenToDelete = [];
      commitNestedUnmounts(childToDelete, (unmountFiber) => {
          switch (unmountFiber.tag) {
              case HostComponent:
                  recordHostChildrenToDelete(rootChildrenToDelete, unmountFiber);
                  // 解绑ref
                  return;
              case HostText:
                  recordHostChildrenToDelete(rootChildrenToDelete, unmountFiber);
                  return;
              case FunctionComponent:
                  // effect相关操作
                  commitPassiveEffect(unmountFiber, root, "unmount");
                  return;
          }
      });
      // @ts-ignore
      if (rootChildrenToDelete.length) {
          const hostParent = getHostParent(childToDelete);
          if (hostParent !== null) {
              rootChildrenToDelete.forEach((node) => {
                  removeChild(node.stateNode, hostParent);
              });
          }
      }
      childToDelete.return = null;
      childToDelete.child = null;
  }
  function commitNestedUnmounts(root, onCommitUnmount) {
      let node = root;
      while (true) {
          onCommitUnmount(node);
          if (node.child !== null) {
              // 向下
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node === root) {
              // 终止条件
              return;
          }
          while (node.sibling === null) {
              // 向上
              if (node.return === null || node.return === root) {
                  // 终止条件
                  return;
              }
              node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }

  const appendAllChildren = (parent, workInProgress) => {
      // 遍历workInProgress所有子孙 DOM元素，依次挂载
      let node = workInProgress.child;
      while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
              appendInitialChild(parent, node.stateNode);
          }
          else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node === workInProgress) {
              return;
          }
          while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress) {
                  return;
              }
              node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
      }
  };
  const bubbleProperties = (completeWork) => {
      let subtreeFlags = NoFlags;
      let child = completeWork.child;
      while (child !== null) {
          subtreeFlags |= child.subtreeFlags;
          subtreeFlags |= child.flags;
          child.return = completeWork;
          child = child.sibling;
      }
      completeWork.subtreeFlags |= subtreeFlags;
  };
  function markUpdate(fiber) {
      fiber.flags |= Update;
  }
  const completeWork = (workInProgress) => {
      const newProps = workInProgress.pendingProps;
      const current = workInProgress.alternate;
      switch (workInProgress.tag) {
          case HostComponent:
              if (current !== null && workInProgress.stateNode) {
                  // 更新
                  // TODO 更新元素属性
                  // 不应该在此处调用updateFiberProps，应该跟着判断属性变化的逻辑，在这里打flag
                  // 再在commitWork中更新fiberProps，我准备把这个过程留到「属性变化」相关需求一起做
                  markUpdate(workInProgress);
              }
              else {
                  // 初始化DOM
                  const instance = createInstance(workInProgress.type, newProps);
                  // 挂载DOM
                  appendAllChildren(instance, workInProgress);
                  workInProgress.stateNode = instance;
                  // TODO 初始化元素属性
              }
              // 冒泡flag
              bubbleProperties(workInProgress);
              return null;
          case HostText:
              if (current !== null && workInProgress.stateNode) {
                  // 更新
                  const oldText = current.memoizedProps?.content;
                  const newText = newProps.content;
                  if (oldText !== newText) {
                      markUpdate(workInProgress);
                  }
              }
              else {
                  // 初始化DOM
                  const textInstance = createTextInstance(newProps.content);
                  workInProgress.stateNode = textInstance;
              }
              // 冒泡flag
              bubbleProperties(workInProgress);
              return null;
          case FunctionComponent:
          case HostRoot:
          case Fragment:
              bubbleProperties(workInProgress);
              return null;
          default:
              console.error("completeWork未定义的fiber.tag", workInProgress);
              return null;
      }
  };

  let syncQueue = null;
  let isFlushingSyncQueue = false;
  function scheduleSyncCallback(callback) {
      if (syncQueue === null) {
          syncQueue = [callback];
      }
      else {
          syncQueue.push(callback);
      }
  }
  //开启 一个微任务
  // queueMicrotask(() => {
  //   console.log('微任务 2');
  // });
  const scheduleMicroTask = typeof queueMicrotask === "function"
      ? queueMicrotask
      : typeof Promise === "function"
          ? (callback) => Promise.resolve(null).then(callback)
          : setTimeout;
  function flushSyncCallbacks() {
      if (!isFlushingSyncQueue && syncQueue) {
          isFlushingSyncQueue = true;
          try {
              //实际上就是执行render函数
              syncQueue.forEach((callback) => callback());
          }
          catch (e) {
              {
                  console.error("flushSyncCallbacks报错", e);
              }
          }
          finally {
              isFlushingSyncQueue = false;
              syncQueue = null;
          }
      }
  }

  let workInProgress = null;
  let wipRootRenderLane = NoLane;
  let rootDoesHasPassiveEffects = false;
  function scheduleUpdateOnFiber(fiber, lane) {
      // fiberRootNode
      const root = markUpdateLaneFromFiberToRoot(fiber);
      markRootUpdated(root, lane);
      ensureRootIsScheduled(root);
  }
  function markUpdateLaneFromFiberToRoot(fiber, lane) {
      let node = fiber;
      let parent = node.return;
      while (parent !== null) {
          node = parent;
          parent = node.return;
      }
      if (node.tag === HostRoot) {
          return node.stateNode;
      }
      return null;
  }
  //会被执行三次
  function ensureRootIsScheduled(root) {
      const updateLane = getHighestPriorityLane(root.pendingLanes);
      if (updateLane === NoLane) {
          return;
      }
      if (updateLane === SyncLane) {
          // 同步优先级 用微任务调度
          // [performSyncWorkOnRoot, performSyncWorkOnRoot, performSyncWorkOnRoot]
          //实际上就是在数组中添回调函数
          scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root, updateLane));
          //
          scheduleMicroTask(flushSyncCallbacks);
      }
      // root.callbackNode = newCallbackNode;
      // root.callbackPriority = curPriority;
  }
  function performSyncWorkOnRoot(root, lane) {
      const nextLane = getHighestPriorityLane(root.pendingLanes);
      if (nextLane !== SyncLane) {
          // 其他比SyncLane低的优先级
          // NoLane
          ensureRootIsScheduled(root);
          return;
      }
      {
          console.warn("render阶段开始");
      }
      // 初始化操作
      prepareFreshStack(root, lane);
      // render阶段具体操作
      do {
          try {
              workLoop();
              break;
          }
          catch (e) {
              console.error("workLoop发生错误", e);
              workInProgress = null;
          }
      } while (true);
      const finishedWork = root.current.alternate;
      root.finishedWork = finishedWork;
      root.finishLane = lane;
      wipRootRenderLane = NoLane;
      // commit阶段操作
      commitRoot(root);
  }
  function commitRoot(root) {
      const finishedWork = root.finishedWork;
      // debugger;
      if (finishedWork === null) {
          return;
      }
      {
          console.log("开始commit阶段", finishedWork);
      }
      const lane = root.finishLane;
      if (lane === NoLane && true) {
          console.error("-----");
      }
      // 重置
      root.finishedWork = null;
      root.finishLane = NoLane;
      markRootFinished(root, lane);
      if ((finishedWork.flags & PassiveMask) !== NoFlags ||
          (finishedWork.subtreeFlags & PassiveMask) !== NoFlags) {
          if (!rootDoesHasPassiveEffects) {
              rootDoesHasPassiveEffects = true;
              // 调度副作用
              scheduler.unstable_scheduleCallback(scheduler.unstable_NormalPriority, () => {
                  // 执行副作用
                  flushPassiveEffects(root.pendingPassiveEffects);
                  return;
              });
          }
      }
      function flushPassiveEffects(pendingPassiveEffects) {
          let didFlushPassiveEffect = false;
          pendingPassiveEffects.unmount.forEach((effect) => {
              didFlushPassiveEffect = true;
              commitHookEffectListUnmount(Passive, effect);
          });
          pendingPassiveEffects.unmount = [];
          pendingPassiveEffects.update.forEach((effect) => {
              didFlushPassiveEffect = true;
              commitHookEffectListDestroy(Passive | HookHasEffect, effect);
          });
          pendingPassiveEffects.update.forEach((effect) => {
              didFlushPassiveEffect = true;
              commitHookEffectListCreate(Passive | HookHasEffect, effect);
          });
          pendingPassiveEffects.update = [];
          flushSyncCallbacks();
          return didFlushPassiveEffect;
      }
      const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
      const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
      if (subtreeHasEffect || rootHasEffect) {
          // 有副作用要执行
          // 阶段1/3:beforeMutation
          // 阶段2/3:Mutation
          commitMutationEffects(finishedWork, root);
          // Fiber Tree切换
          root.current = finishedWork;
          // 阶段3:Layout
      }
      else {
          // Fiber Tree切换
          root.current = finishedWork;
      }
      rootDoesHasPassiveEffects = false;
      ensureRootIsScheduled(root);
  }
  function prepareFreshStack(root, lane) {
      workInProgress = createWorkInProgress(root.current, {});
      wipRootRenderLane = lane;
  }
  function workLoop() {
      // debugger;
      while (workInProgress !== null) {
          performUnitOfWork(workInProgress);
      }
  }
  function performUnitOfWork(fiber) {
      const next = beginWork(fiber, wipRootRenderLane);
      // 执行完beginWork后，pendingProps 变为 memoizedProps
      fiber.memoizedProps = fiber.pendingProps;
      if (next === null) {
          completeUnitOfWork(fiber);
      }
      else {
          workInProgress = next;
      }
  }
  function completeUnitOfWork(fiber) {
      let node = fiber;
      do {
          const next = completeWork(node);
          if (next !== null) {
              workInProgress = next;
              return;
          }
          const sibling = node.sibling;
          if (sibling) {
              workInProgress = sibling;
              return;
          }
          node = node.return;
          workInProgress = node;
      } while (node !== null);
  }
  function markRootUpdated(root, lane) {
      root.pendingLanes = mergeLanes(root.pendingLanes, lane);
  }

  function createContainer(container) {
      const hostRootFiber = new FiberNode(HostRoot, {}, null);
      const root = new FiberRootNode(container, hostRootFiber);
      hostRootFiber.updateQueue = createUpdateQueue();
      return root;
  }
  function updateContainer(element, root) {
      const hostRootFiber = root.current;
      const lane = requestUpdateLane();
      const update = createUpdate(element, lane);
      enqueueUpdate(hostRootFiber.updateQueue, update);
      scheduleUpdateOnFiber(hostRootFiber, lane);
      return element;
  }

  function createRoot(container) {
      const root = createContainer(container);
      return {
          render(element) {
              initEvent(container, "click");
              return updateContainer(element, root);
          },
      };
  }

  var ReactDOM = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createRoot: createRoot
  });

  return ReactDOM;

}));
