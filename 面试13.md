1.事件注册
1.1.在 fiber 架构中，有些事件是绑定在 div#root 上;有些事件没有做事件委托(没有放到 div#root 层，而是放到当前 dom 节点上,例如下面的)

export const nonDelegatedEvents: Set<DOMEventName> = new Set([
'beforetoggle',
'cancel',
'close',
'invalid',
'load',
'scroll',
'scrollend',
'toggle',
...mediaEventTypes,
]);

(1.2).react 将事件名穷举放在了 DOMEventProperties.js 文件中，定义了一个变量 simpleEventPluginEvents 用来保存简单事件名
const simpleEventPluginEvents = [
'click',
'abort',
'auxClick',
'beforeToggle',
'cancel',
'canPlay',
'canPlayThrough',
'click',
'close',
'contextMenu',
'copy',
'cut',
'drag',
'dragEnd',
]
什么是简单事件？简单事件是 onClick 只依赖了 click 事件，而复合事件是由多个事件合成的，比如：onMouseEnter，它依赖了 mouseout 和 mouseover，这里我们只用 click 举例

1.3.遍历事件名数组，将事件名转换成首字母大写，比如 click 转换成 Click，在转换成 onClick

1.4.调用 registerSimpleEvent 函数注册简单事件(这个函数主要完成两件事：保存原生事件和 react 事件的对应关系)

1.5 它将不同类型的事件做成了插件，每个插件提供注册事件和提取事件两个接口，插件自身去实现事件的注册和事件提取

1.6 给 div#root 绑定好所有定义好的事件，每个事件都有捕获和冒泡两个阶段

2.事件派发
2.1 不管是冒泡还是捕获，从事件触发源到事件绑定的节点，所经过的事件都要触发

<div onClick={onClickParent}>
  <div onClick={onClickChild}>事件触发</div>
</div>

当点击【事件触发】按钮时，触发顺序：
冒泡：先触发 onClickChild，再触发 onClickParent
捕获：先触发 onClickParent，在触发 onClickChild

2.2 开始事件注册时，不同类型的事件由不同的事件插件进行注册，那么对于事件函数的提取也是有插件去完成（事件提取的时候会创造一个 SyntheticEvent 主要目的是：抹平浏览器之间的差异，阻止默认事件和阻止冒泡在不同的浏览器之间实现的方式不一样）
阻止默认事件：event.preventDefault() 和 event.returnValue = false
阻止冒泡：event.stopPropagation() 和 event.cancelBubble = true

2.3 我们需要将绑定的事件从上到下都要收集起来，放在一个队列中。从事件源对应的 Fiber 开始，向上遍历所有的父 Fiber(Fiber.return)，收集所有遍历到的节点中的事件函数，然后将事件函数保存到事件函数的队列中（比如上面先收集 onClickChild，再收集 onClickParent）

2.4 事件派发
2.4.1 拿到原生事件对象(拿到原生事件源，不同的浏览器事件源不一样，IE 浏览器是 nativeEvent.srcElement，其他浏览器是 nativeEvent.target)
2.4.2 拿到原生事件源所对应的 fiber
2.5 派发事件

2.5 遍历事件函数的队列，拿到每个事件函数队列，依次执行事件函数
具体的执行过程：
判断是不是捕获阶段
如果是捕获阶段，就从后往前执行
如果是冒泡阶段，就从前往后执行
在执行事件函数之前，如果事件被阻止了，则不在继续执行事件函数

总结：通过 react 合成事件的学习，学习 react 对于事件系统的分层设计，它将不同类型的事件做成了插件，每个插件提供注册事件和提取事件两个接口，插件自身去实现事件的注册和事件提取
事件系统核心原理比较简单，主要的作用是抹平各浏览器之间的差异
