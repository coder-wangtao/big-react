1.当在 App 组件中触发 setState 时，重新走 beginWork=> completeWork => commitWork,此时还是从 hostRootFiber 开始触发 beginWork

2.beginWork 递 (更新)
建立节点的父子以及兄弟节点的关联关系 child return sibling
给 fiber 节点打上 flags 标记
<HostRoot>
<A>
<B/>
</A>
<HostRoot>
当进入 HostRoot 的 beginWork 时，通过对比 A currentFiberNode 与 HostRoot 生成的 A reactElement, 生成 A 对应的 wip fiberNode
当进入 A 的 beginWork 时，通过对比 B currentFiberNode 与 A 生成的 B reactElement, 生成 B 对应的 wip fiberNode

理论上 mount 流程完毕后所包含的 flags:
两年半 Placement
span Placement
练习时长 Placement
p Placement
div Placement
相比于执行 5 次 Placement 我们可以构建好离屏的 dom 树后，对 div 执行 1 次 Placement 操作

2.completeWork 归 (更新)
创建真实的 dom 节点，但是还没有渲染到页面中

<!--
针对如下的 dom 结构
const A = () => {
    return (
        <div>
            <B />
            <B />
        </div>
    );
};
const B = () => {
    return <div>1</div>;
};
*/ -->

归的时候去插入元素，遇到非 dom 的 fiberNode, 跳过向下遍历，直到找到 dom 就插入，遍历完回到最初的元素(最顶的元素)就跳出循环。
处理 flags，合并 subTreeFlag
bubbleProperties() 冒泡 subtreeFlags
寻找当前 fiberNode 下 子 fiberNode 的 flags 和 subsubTreeFlag, while 循环找 child，然后再找 sibling
建立真实 dom 的关系，把子 dom 插入到父 dom 中

3.commitWork
commitWork 利用 finishWork 指针，先递后归，递：直到找到 subTreeFlags:NoFlag，就把 completeWork 生成的 dom 树插入到 div#root 中

4.diff 算法
diff 的三大原则：更新前后，层级一致;更新前后，类型一致；更新前后，key 相同(没有 key，默认就是 index)。
移动：
老的 123 新的 231
遍历是新的：从左到右 index 0 1 2

2 -> 老 index 1
3 -> 老 index 2
1 -> 老 index 0
老 index 2 > 老 index 1,此时灭没有有问题，说明 3 不需要移动。
老 index 0 < 老 index 2,此时有问题,说明 1 要移动，打上标记 Placement

删除:
老的 123 新的 32
创建一个 map，把老的存到 map 里面，map = {1,2,3},每遍历一次新的，就会把 map 中老的删掉，最后，map 中剩下的元素 dom 移除
新增：
老的 123 新的 3214
遍历新的，发现老的没有，创建。
