1.当在 App 组件中触发 setState 时，重新走 beginWork=> completeWork => commitWork,此时还是从 hostRootFiber 开始触发 beginWork

2.beginWork 递 (更新)
建立节点的父子以及兄弟节点的关联关系 child return sibling
给 fiber 节点打上 flags 标记
<HostRoot>
<A>
<B/>
</A>
<HostRoot>
当进入 HostRoot 的 beginWork 时，通过对比 A currentFiberNode 与 HostRoot 生成的 A reactElement, 生成 A 对应的 wip fiberNode
当进入 A 的 beginWork 时，通过对比 B currentFiberNode 与 A 生成的 B reactElement, 生成 B 对应的 wip fiberNode

3.diff 算法(diff 算法发生在 beginWork 递阶段)
diff 的三大原则：更新前后，层级一致;更新前后，类型一致；更新前后，key 相同(没有 key，默认就是 index)。
移动：
老的 FiberNode: 123; 新的 ReactElement: 231
遍历新的 ReactElement：从左到右 index 0 1 2，复用老的 FiberNode，生成 2、3、1 的 FiberNode,同时新的、老的 FiberNode 指向同一个 StateNode,(新老 FiberNode 可以复用的情况)

2 -> 老 index 1
3 -> 老 index 2
1 -> 老 index 0
老 index 2 > 老 index 1,此时没有有问题，说明 3 不需要移动。
老 index 0 < 老 index 2,此时有问题,说明 1 要移动，打上标记 Placement

删除:
老的 123 新的 32
创建一个 map，把老的存到 map 里面，map = {1,2,3},每遍历一次新的，就会把 map 中老的删掉，最后，map 中剩下的元素 dom 移除，父级的 FiberNode.deletions = [1 FiberNode],父级的 FiberNode.flags(打上标记) = ChildDeletion

新增：
老的 123 新的 3214
遍历新的，发现老的没有，创建。创建一个新的 4FiberNode,打上标记 Placement

线性扫描
React 会从左到右线性扫描新旧两个列表，尝试直接按位置进行节点的复用。这个阶段会处理以下几种情况：
更新：如果新旧节点在相同位置且 key 和 type 都相同，React 会复用旧节点并更新其属性，然后继续比较它们的子节点。
遇到第一个 key 或 type 不匹配的节点，这个时候就会跳转到第二阶段进行哈希比较。
哈希映射比较
React 会继续遍历新列表中剩余的未处理节点，并尝试在 Map 中查找匹配的 key,基于：lastPlacedIndex

4.completeWork 归 (更新)
处理 props、className style、ref 是否变化,增加 Update flag
bubbleProperties() 冒泡 subtreeFlags
寻找当前 fiberNode 下 子 fiberNode 的 flags 和 subsubTreeFlag, while 循环找 child，然后再找 sibling

5.commitWork(深度优先遍历)(更新)
commitWork 利用 finishWork 指针，先递后归，递：直到找到 subTreeFlags:NoFlag(表示子节点没有变化)， 就向上归：沿途处理 FiberNode 节点上的 flags(Placement、Update、ChildDeletion),更新 FiberNode.stateNode 上的真实 dom。FiberNode 节点上的 Flags 处理完毕后，FiberNode.flags = 0
在其内部大体上可以分为四个阶段，React 按顺序执行以下操作:
Before Mutation Effects: 这是在 DOM 突变之前执行的副作用。
DOM Mutations: 这是 React 实际将变更应用到 DOM 的阶段。修改真实 dom、解绑之前的 ref
Layout Effects: 这是在 DOM 突变完成后，同步执行的副作用。useRef(绑定新 ref) useLayoutEffect 在这里执行
Passive Effects: 这是 React 用于异步执行副作用的阶段。

