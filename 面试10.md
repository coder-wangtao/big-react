1.性能优化
性能优化的一般思路：当变化的部分与不变的部分分离
什么事变化的部分？
State Props Context
命中性能优化的组件可以不通过 reconcile 生成 wip.child,而是直接复用上次更新生成的 wip.child
总体来说有两点： 1.性能优化的思路是将变化的部分与不变的部分分离 2.命中性能优化的组件的子组件（而不是它本身不需要 render）

2.react 中的两种性能优化策略
2.1 bailout 策略：减少不必要的子组件 render
2.2 eagerState 策略：不必要的更新，没必要开启后续调度流程（原理的 state 是 1，更新后还是 1，没必要走调度流程渲染组件）

3.bailout
命中性能优化(bailout 策略)的组件可以不通过 reconcile 生成 wip.child,而是直接复用上次更新生成的 wip.child
bailout 策略存在于 beginWork 中：
bailout 四要素：
1.props 不变：比较 props 变化是通过全等比较(两个对象的引用地址是否一致，比较难触发)，使用 React.memo 后会变成浅比较
2.state 不变：两种情况可能造成 state 不变：1.不存在 update;2.存在 update，但是计算得出的 state 没有变化
3.context 不变
4.type 不变(如果 div 变成 p,返回值肯定变了)

第一次挂载是不会触发 bailout 策略的
HostRoot 根节点是一定会触发 bailout
beginWork 的作用主要是生成 wipFiberNode 的子 FiberNode，要到达这个目的存在两种方式： 1.通过 reconcile 流程生成子 FiberNode 2.命中 bailout 策略来复用子 FiberNode

beginWork 第一次判断是否命中 bailout 策略：
bailout 四要素
1.props 不变：比较 props 变化是通过全等比较(两个对象的引用地址是否一致，比较难触发)，使用 React.memo 后变成浅比较

oldProps === newProps,这里做的是一个全等比较，组件在 render 之后，拿到的是一个 React 元素，因此这里比较就是针对前后 react 元素的 props 属性进行一个比较，
如果 props 属性每一项都没有发生变化，会被认为是一样的，但是这里有一个注意点，就是每一次 组件 render 的时候，会生成一个全新的对象引用，因此 oldProps 和 newProps 并不会全都等，此时是没法命中 bailout，只有当父 FiberNode 命中 bailout 策略时，复用子 FiberNode，在子 FiberNode 的 beginWork 中，oldProps 才有可能与 newProps 全等。

2.存不存在更新：

两种情况可能造成 state 不变
不存在 state
存在 update,但是计算得出的 state 没变化

3.context 不变
4.type 不变

<!-- function App(){
    const Child = () => <div>child</div>
    return <Child/>
} -->

上面的代码中，在 App 组件中定义了 Child 组件，那么 App 每次 render 之后都会创建新的 Child 的引用，因此对于 Child 来讲，FiberNode.types 始终是变化的，无法命中 bailout 策略，因此不要在组件内部再定义组件，以免无法命中 bailout 策略

以上条件都满足时，会命中 bailout 策，命中该策略后，会执行 bailoutOnAlreadyFinishedWork 方法，该方法会进一步的判断优化程度（childLanes），根据优化程度来决定是整颗子树都命中 bailout（childLanes）还是复用子树的 FiberNode
命中的情况下：不会走 reconcile 的流程：直接通过 currentFiber 的 child currentChild,copy 生成一个 子 fiberNode

beginWork 第二次判断是否命中 bailout 策略：

1.开发者使用了性能优化 API
第一次判断的时候，默认是对 props 进行全等比较，要满足这个条件是比较困难的，性能优化 API 的工作原理主要就是改写这个判断条件。
比如 React.memo，通过 API 创建的 FC 对应的 FiberNode.tag 为 MemoComponent,在 beginWork 中处理的逻辑：改变 bailout 策略的命中条件
bailout 就变成三个: 1.存不存在更新; 2.经过比较（浅比较）后 props 没有变化; 3.ref 没有发生变化
相较于第一次判断 props 采用的是浅比较进行判断，因此能够更容易命中 bailout
ClassComponent 的优化手段经常会涉及 PureComponent 或者 shouldComponentUpdate,这两个 api 实际上也是在优化命中 bailout 策略的方式

2.虽然有更新的，但是 state 没有变化（重要）
第一次判断的时候，其中一个条件是当前 FiberNode 没有更新发生，没有更新就意味着 state 没有哦改变，但是还有一种情况，那就是有更新，但是更新后计算出来 state 仍然没有变化，此时也会命中 bailout 的策略

4.eagerState
eagerState 策略：状态更新前后没有变化，那么没有必要触发更新
为此需要做：1.计算更新后的状态，2.与更新前的状态作比较
如果某个状态更新前后没有变化，那么就可以跳过后续的更新流程
只有满足《当前 FiberNode 没有其他更新》才尝试进入 eagerState
state 是基于 update 计算的，计算的过程发生在 render 的 beginWork UpdateFunctionComponent,而 eagerState 则是将计算过程提前到了 schedule 之前执行
该策略有一个前提条件，那就是当前的 FiberNode 不存在待执行的更新，因为如果不存在待执行的更新，那么当前的更新就是第一个更新，那么计算出来的 state 即便有变化也可以作为后续更新的基础 state 来使用

5.React.memo
bailout 四要素中对于 props 的比较是全等比较，如果父组件命中 bailout,子组件是被复用的，如果子组件是被复用的话，那么它的 props 就是跟上一次 props 是一样的，这样就可以满足四要素中对于 props 对比。如果子组件不是被复用的，是通过 reconcile 流程生成的，子组件 props 就是一个全新的对象，前后两个对象的引用地址肯定是不一致的。 这种情况下就可以使用 React.memo
React.memo 的作用：让 props 的全等比较，props 的浅比较
React.memo 的本质：在子组件与父组件增加一个 MemoComponent,MemoComponent 通过 props 浅比较命中 bailout 策略(除了浅比较props,还需要比较state，context,type)
