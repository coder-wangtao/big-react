双缓存机制有什么用？
比如电脑处理图片，一帧一帧处理，每一帧实际上计算机处理是要花费时间的，
第一帧已经播放完了，马上进入第二帧，第二帧的图片还需要处理
第二帧处理的过程中，第一帧不能消失，还显示在屏幕上，直到第二帧处理好，才能进行切换

beiginWork 递
建立节点的父子以及兄弟节点的关联关系 child return sibling
给 fiber 节点打上 flags 标记

completeWork 归
创建真实的 dom 节点，但是还没有渲染到页面中
处理 flags，合并为 subTreeFlag bubbleProperties() 冒泡 subtreeFlags
建立真实 dom 的关系，把子 dom 插入到父 dom 中

commit
真实的 dom 渲染
commitWork 利用 finsihWork 指针，先递后归，递：直到找到 subTreeFlags:NoFlag，就把 completeWork 生成的 dom 树插入到 div#root 中

diff
移动：
老的 123 新的 321
遍历是新的：从左到右 index 0 1 2

3 -> 老 index 2
2 -> 老 index 1
1 -> 老 index 0

此时有问题， 老 index 2 > 老 index 1 说明 2 要移动，打上标记 Placement
此时有问题， 老 index 0 > 老 index 2 说明 1 要移动，打上标记 Placement

删除:
老的 123 新的 32
创建一个 map，把老的存到 map 里面，map = {1,2,3},每遍历一次新的，就会把 map 中老的删掉，最后，map 中剩下的元素 dom 移除
新增：
老的 123 新的 3214
遍历新的，发现老的没有，创建。

setCount((count) => {
return count + 1; a
});
setCount((count) => {
return count + 1; b
});
setCount((count) => {
return count + 1; c
});

a => b => c => a => b => c 双端环状列表，为什么要这么设计？ 就是为了方便遍历。

useEffect 回调的执行过程
执行阶段：commit (真实 dom 的修改同步执行，页面的更新)
执行实际：commit 的前面，但是是在下一轮时间循环宏任务异步执行的

并发调度（之后看）

react18
关于可中断:
Concurrent 最主要的特点就是渲染是可中断的。没错，以前是不可中断的，也就是说，
以前 React 中的 update 是同步渲染，在这种情况下，一旦 update 开启，在任务完成前，都不可中断。
Concurrent 模式特点
先说可中断这件事情的重要性。对于 React 来说，任务可能很多，如果不区分优先级，那就是先来后到的顺序。
虽然听起来很合理，但是现实是普通车辆就应该给救护车让路，因为事有轻重缓急嘛。那么在 React 中呢，如果高优先级任务来了，
但是低优先级任务还没有处理完毕，就会造成高优先级任务等待的局面。比如说，某个低优先级任务还在缓慢中，
input 框忽然被用户触发，但是由于主线程被占着，没有人搭理用户，结果是用户哐哐输入，但是 input 没有任何反应。
用户一怒之下就走了，那你那个低优先级的任务还更新个什么呢，用户都没了。
由此可见，对于复杂项目来说，任务可中断这件事情很重要。那么问题来了，React 是如何做到的呢，
其实基础还是 fiber，fiber 本身链表结构，就是指针嘛，想指向别的地方加个属性值就行了。

关于被遗弃:
在 Concurrent 模式下，有些 update 可能会被遗弃掉。先举个 🌰：
比如说，我看电视的时候，切换遥控器，从 1 频道切换到 2 频道，再切换到 3 频道，最后在 4 频道停下来。
假如这些频道都是 UI，那么 2、3 频道的渲染其实我并不关心，我只关心 4 频道的结果，
如果你非要花时间把 2 和 3 频道的 UI 也渲染出来，最终导致 4 频道很久之后才渲染出来，那我肯定不开心。
正确的做法应该是尽快渲染 4 频道就行了，至于 2 和 3 频道，不管渲染了多少了，遗弃了就行了，反正也不需要了。
最后回到项目的实际场景，比如我想在淘宝搜索“老人与海”，那么我在输入框输入“老人与海”的过程中，“老人”会有对应的模糊查询结果，
但是不一定是我想要的结果，所以这个时候的模糊查询框的 update 就是低优先级，“老人”对应 UI 的 update 相对 input 的 update，
优先级就会低一些。在现在 React18 中，这个模糊查询相关的 UI 可以被当做 transition。关于 transition，等下我会有细讲。

关于状态复用:
Concurrent 模式下，还支持状态的复用。某些情况下，比如用户走了，又回来，那么上一次的页面状态应当被保存下来，
而不是完全从头再来。当然实际情况下不能缓存所有的页面，不然内存不得爆炸，所以还得做成可选的。目前，
React 正在用 Offscreen 组件来实现这个功能。另外，使用 OffScreen，除了可以复用原先的状态，我们也可以使用它来当做新 UI 的缓存准备，
就是虽然新 UI 还没登场，但是可以先在后台准备着嘛，这样一旦轮到它，就可以立马快速地渲染出来。

1.react setState 批处理 搞定 v
2.Suspense  
3.SuspenseList

4.transition 搞定
react 把 update 分成两种：
Urgent updates 紧急更新，指直接交互，通常指的用户交互。如点击、输入等。这种更新一旦不及时，用户就会觉得哪里不对。 v
Transition updates 过渡更新，如 UI 从一个视图向另一个视图的更新。通常这种更新用户并不着急看到。 v
4.1 startTransition (原理) 搞定 v
4.2 useTransition (原理) 搞定 v

5.useDeferredValue (原理)
6.useId SSR
7.useSyncExternalStore Library Hooks Recoil
8.useInsertionEffect Library Hooks css-in-js

9.bailout
memo, shouldComponentUpdate , PureComponent

1.为什么在条件语句中不能用 hook?
//hook 在源码里面是一个对象存储的，并且是一个单链表，管理这些 hook 数据，顺序就是区分这些 hook 的唯一标识，如果加入条件语句，
//hook 的顺序是不固定的，在内存中无法区分（没有 key 值，只有顺序）,所以要保证 hook 的顺稳定性

2.class 组件中，事件中 this 为什么是 undefined?
//源码中 对事件调用使用 apply() ，而 apply 中传入了 undefined

useRef

vue 的批处理是在微任务中执行的
react 的批处理正常也是在微任务中处理的，但是在 useTransition 中的执行的批处理是在宏任务中处理的。
