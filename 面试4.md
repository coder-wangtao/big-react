1.react 中批处理（useState）
react 正常情况下时是在微任务中执行批处理的

<!--
setCount((count) => {
    return count + 1; a
});
setCount((count) => {
    return count + 1; b
});
setCount((count) => {
    return count + 1; c
});
-->

上面的例子，只会创建一个 update，每一个 update 都会有一个 lane,这个 update 是一个双端环状列表，a->b->c=> a,这个双端环状列表默认执行最后一个(c)，c.next 就是第一个。当消费这个更新的时候，从 c.next(就是第一个)开始顺着 next 开始遍历，依次执行每一个回调，完成更新。
useState a => b => c => a => b => c 双端环状列表，为什么要这么设计？ 就是为了方便遍历。

多次触发更新，意味着对于同一个 Fiber,会创建多个 update，例如上面的例子，会创建多个 update；多次触发更新，只进行一次更新流程，意味着到达成三个目标：
《1》.需要实现一套优先级机制，每个更新都拥有优先级。
《2》.需要能够合并一个宏任务/微任务中触发的所有更新。
《3》.需要实现一套算法，用于决定哪个优先级优先进入 render 阶段。

setCount setCount setCount 三次 setState,会触发三次更新任务,[更新任务回调 1,更新任务回调 2,更新任务回调 3]形成一个数组,在微任务中取出数组里的每一个回调，依次执行。更新任务 1 执行完完毕后，会把当前任务的 lane 置为 NoLane，代表没有 update ，意味着没有更新。那么更新任务回调 2,更新任务回调 3 就不会执行了

但是使用 useTransition 之后，批处理是在宏任务中执行
const [isPending,startTransition] = useTransition()

<!--
startTransition(() => {
    setCount((count) => {
        return count + 1; a
    });
    setCount((count) => {
        return count + 1; b
    });
    setCount((count) => {
        return count + 1; c
    });
})
-->

2.Lane 模型
2.1 lane 为什么会产生？
对于不同情况触发的更新，产生 lane。为后续不同事件产生不同优先级更新做准备。
lane:二进制，代表优先级
lanes:二进制，代表 lane 的集合
2.2 如何知道那些 lane 被消费了，还剩那些 lane 没有被消费？
FiberRootNode 增加两个字段：pendingLanes 代表所有未被消费的 lane 的集合 2.finishLanes 代表本次更新消费的 lane。
首先触发更新，创建一个 update，update 会拥有一个 lane。然后进入 schedule 阶段，在 schedule 阶段会在 FiberRootNode 中记录这个 lane 是什么。在 schedule 阶段通过某一些逻辑选出一个 lane(取最小的 lane),进入 render(beginwork、completeWork) 阶段，commit（commitWork） 阶段。等 commit（commitWork） 阶段结束之后，就会从 FiberRootNode 中把 schedule 阶段选出的 lane 移除掉，移除完以后。又循环回 schedule 阶段，schedule 阶段就会寻找还有没有剩余其他 lane，如果有的话在 schedule 阶段通过某一些逻辑选出一个 lane(取最小的 lane),再进入 render(beginwork、completeWork) 阶段、commit（commitWork） 阶段。等 commit（commitWork） 阶段结束之后，就会从 FiberRootNode 中把 schedule 阶段选出的 lane 移除掉，移除完以后。又循环回 schedule 阶段(反复循环)，直到 schedule 阶段找不出新的 lane 了，就代表所有更新都执行完了。
2.3 schedule 阶段逻辑（对应 ensureRootIsScheduled）
首次渲染 setState 更新都是同步优先级，用微任务调度

<!--
export function ensureRootIsScheduled(root: FiberRootNode) {
  const updateLane = getNextLane(root);  //从FiberRootNode获取当前最小的lane

  if (updateLane === NoLane) {
    //没有lane 代表没有update 代表没有更新
    return;
  }
  if (updateLane === SyncLane) {
    // 同步优先级 用微任务调度
    //queueMicrotask/Promise.then
  } else {
    // 其他优先级(宏任务)用宏任务调度
    //调度器调度
    const schedulerPriority = lanesToSchedulerPriority(updateLane);
    newCallbackNode = scheduleCallback(
      schedulerPriority,
      // @ts-ignore
      performConcurrentWorkOnRoot.bind(null, root),
    );
  }
} -->
