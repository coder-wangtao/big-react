(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (global.client = global.client || {}, global.client.js = factory()));
})(this, (function () { 'use strict';

  const FunctionComponent = 0;
  const HostRoot = 3;
  //<div></div>
  const HostComponent = 5;
  const HostText = 6;

  const NoFlags = 0b0000001;
  const Placement = 0b0000010; //跟结构相关
  const Update = 0b0000100; //跟属性相关
  const ChildDeletion = 0b0001000; //跟结构相关
  const MutationMask = Placement | Update | ChildDeletion;
  // React 利用了 | 运算符的特性来存储 flags，如：
  // const flags = Placement | Update; //此时 flags = 0b0000110
  //React 中会用一个 flags & 某一个 flag，来判断 flags 中是否包含某一个 flag，如：
  // const flags = Placement | Update; //此时 flags = 0b0000110
  // Boolean(flags & Placement); // true, 说明 flags 中包含 Placement
  // Boolean(flags & ChildDeletion); // false, 说明 flags 中不包含 ChildDeletion
  //在 React 中，~ 运算符同样是常用操作，如：通过 ~ 运算符与 & 运算符的结合，从 flags 中删除了 Placement 这个 flag。
  // let flags = Placement | Update; //此时 flags = 0b0000110
  // flags &= ~Placement; //此时 flags = 0b0000100

  class FiberNode {
      type; //节点的类型，可以是原生 DOM 元素、函数组件或类组件等；
      tag; //
      key;
      stateNode; //节点对应的实际 DOM 节点或组件实例；
      ref;
      // 构成树状结构
      return; //指向节点的父节点；
      sibling; //指向节点的下一个兄弟节点；
      child; //指向节点的第一个子节点；
      index; // 索引
      // 作为工作单元
      memoizedProps; // 已经更新完的属性
      memoizedState; // 更新完成后新的 State
      alternate; //指向节点的备份节点，用于在协调过程中进行比较；
      pendingProps; //表示节点的新属性，用于在协调过程中进行更新。
      flags; // 表示节点的副作用类型，如更新、插入、删除等
      subtreeFlags; // 表示子节点的副作用类型，如更新、插入、删除等
      updateQueue; //更新计划队列
      constructor(tag, pendingProps, key) {
          this.tag = tag;
          this.key = key;
          //HostComponent <div> div DOM
          this.stateNode = null;
          this.type = null;
          //执行父FiberNode
          this.return = null;
          this.sibling = null;
          this.child = null;
          this.index = 0;
          this.ref = null;
          this.pendingProps = pendingProps;
          this.memoizedProps = null;
          this.memoizedState = null;
          this.updateQueue = null;
          this.alternate = null;
          //副作用
          this.flags = NoFlags;
          this.subtreeFlags = NoFlags;
      }
  }
  class FiberRootNode {
      container;
      current;
      finishedWork;
      constructor(container, hostRootFiber) {
          this.container = container;
          this.current = hostRootFiber;
          hostRootFiber.stateNode = this;
          this.finishedWork = null;
      }
  }
  //生成与 hostRootFiber 对应的 workInProgress hostRootFiber；
  const createWorkInProgress = (current, pendingProps) => {
      let wip = current.alternate; //指向节点的备份节点，用于在协调过程中进行比较；第一次为null
      if (wip === null) {
          //mount
          wip = new FiberNode(current.tag, pendingProps, current.key);
          wip.stateNode = current.stateNode;
          wip.alternate = current; //备份节点
          current.alternate = wip;
      }
      else {
          //update
          wip.pendingProps = pendingProps;
          wip.flags = NoFlags;
          wip.subtreeFlags = NoFlags;
      }
      wip.type = current.type;
      wip.updateQueue = current.updateQueue;
      wip.child = current.child;
      wip.memoizedProps = current.memoizedProps;
      wip.memoizedState = current.memoizedState;
      return wip;
  };
  function createFiberFromElement(element) {
      const { type, key, props } = element;
      let fiberTag = FunctionComponent;
      if (typeof type === "string") {
          fiberTag = HostComponent;
      }
      else if (typeof type !== "function" && true) {
          console.warn("未定义的type类型", element);
      }
      const fiber = new FiberNode(fiberTag, props, key);
      fiber.type = type;
      return fiber;
  }
  //当所有 React Element 都比较完成之后，会生成一棵新的 Fiber 树，此时，一共存在两棵 Fiber 树：
  // current: 与视图中真实 UI 对应的 Fiber 树，当 React 开始新的一轮渲染时，会使用
  // current 作为参考来比较新的树与旧树的差异，决定如何更新 UI；
  // workInProgress: 触发更新后，正在 Reconciler 中计算的 Fiber 树，一旦 workInProgress 上的更新完成，
  // 它将会被提交为新的current，成为下一次渲染的参考树，并清空旧的 current 树。

  // 创建 Update 实例的方法
  const createUpdate = (action) => {
      return {
          action,
      };
  };
  // 创建 UpdateQueue 实例的方法
  const createUpdateQueue = () => {
      return {
          shared: {
              pending: null,
          },
      };
  };
  // Update（更新）
  // Update 表示对组件状态的一次更新操作。
  // 当组件状态发生变化时（例如由 setState 触发），React 会创建一个 Update 对象，其中包含了新的状态或者状态的更新部分。
  // Update 对象描述了如何修改组件的状态，如添加新的状态、更新现有的状态、删除状态等，以及与此更新相关的一些元数据，如优先级等。
  // Update 对象记录了组件状态的变化，但实际的状态更新并不会立即执行，而是会被添加到更新队列中等待处理。
  // UpdateQueue（更新队列）
  // UpdateQueue 是一个队列数据结构，用于存储组件的更新操作。
  // 当组件的状态发生变化时，会生成一个新的 Update 对象，并将其添加到组件的 UpdateQueue 中。
  // UpdateQueue 管理着组件的状态更新顺序，确保更新操作能够按照正确的顺序和优先级被应用到组件上。
  // 更新队列通常是以链表的形式实现的，每个 Update 对象都链接到下一个更新对象，形成一个更新链表。
  // 在 React 的更新过程中，会遍历更新队列，并根据其中的更新操作来更新组件的状态以及更新 DOM。
  // 将 Update 添加到 UpdateQueue 中的方法
  const enqueueUpdate = (updateQueue, update) => {
      updateQueue.shared.pending = update;
  };
  // 从 UpdateQueue 中消费 Update 的方法
  const processUpdateQueue = (baseState, pendingUpdate) => {
      const result = {
          memoizedState: baseState,
      };
      if (pendingUpdate !== null) {
          const action = pendingUpdate.action;
          if (action instanceof Function) {
              //baseState 1 update (x) => 4x -> memoizedState 4
              result.memoizedState = action(baseState);
          }
          else {
              //baseState 1 update 2 -> memoizedState 2
              result.memoizedState = action;
          }
      }
      return result;
  };

  const supportSymbol = typeof Symbol === "function" && Symbol.for;
  const REACT_ELEMENT_TYPE = supportSymbol
      ? Symbol.for("react.element")
      : 0xeac7;

  function ChildReconciler(shouldTrackEffects) {
      // 处理单个 Element 节点的情况
      // 对比 currentFiber 与 ReactElement
      // 生成 workInProgress FiberNode
      function reconcileSingleElement(returnFiber, currentFiber, element) {
          const fiber = createFiberFromElement(element);
          fiber.return = returnFiber;
          return fiber;
      }
      // 处理文本节点的情况
      // 对比 currentFiber 与 ReactElement
      // 生成 workInProgress FiberNode
      function reconcileSingleTextNode(returnFiber, currentFiber, content) {
          const fiber = new FiberNode(HostText, { content }, null);
          fiber.return = returnFiber;
          return fiber;
      }
      // 为 Fiber 节点添加更新 flags
      function placeSingleChild(fiber) {
          // 首屏渲染且追踪副作用时，才添加更新 flags
          if (shouldTrackEffects && fiber.alternate === null) {
              fiber.flags |= Placement;
          }
          return fiber;
      }
      // 闭包，根绝 shouldTrackSideEffects 返回不同 reconcileChildFibers 的实现
      return function reconcileChildFibers(returnFiber, currentFiber, newChild) {
          // 判断当前 fiber 的类型
          // 单个 Element 节点
          if (typeof newChild === "object" && newChild !== null) {
              switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                      return placeSingleChild(reconcileSingleElement(returnFiber, currentFiber, newChild));
                  default:
                      {
                          console.warn("未实现的reconcile类型", newChild);
                      }
                      break;
              }
          }
          //多节点的情况
          // 多个 Element 节点
          if (Array.isArray(newChild)) {
              // TODO: 暂时不处理
              {
                  console.warn("未实现的 reconcile 类型", newChild);
              }
          }
          // 文本节点
          if (typeof newChild === "string" || typeof newChild === "number") {
              return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFiber, newChild));
          }
          {
              console.warn("未实现的reconcile类型", newChild);
          }
          return null;
      };
  }
  // 组件的更新阶段中，追踪副作用
  const reconcileChildFibers = ChildReconciler(true);
  // 首屏渲染阶段中不追踪副作用，只对根节点执行一次 DOM 插入操作
  const mountChildFibers = ChildReconciler(false);

  // 比较并返回子 FiberNode
  // beginWork 函数在向下遍历阶段执行，根据 Fiber 节点的类型（HostRoot、HostComponent、HostText）
  // 分发任务给不同的处理函数，处理具体节点类型的更新逻辑：
  // HostRoot
  // 表示根节点，即应用的最顶层节点；
  // 调用 updateHostRoot 函数，处理根节点的更新，包括协调处理根节点的属性以及子节点的更新逻辑；
  // 调用 reconcileChildren 函数，处理根节点的子节点，可能会递归调用其他协调函数；
  // 返回 workInProgress.child 表示经过协调后的新的子节点链表；
  // HostComponent
  // 表示原生 DOM 元素节点，例如 <div>、<span> 等；
  // 调用 updateHostComponent 函数，处理原生 DOM 元素节点的更新，负责协调处理属性和子节点的更新逻辑；
  // 调用 reconcileChildren 函数，处理原生 DOM 元素的子节点更新；
  // 返回 workInProgress.child 表示经过协调后的新的子节点链表；
  // HostText
  // 表示文本节点，即 DOM 中的文本内容，例如 <p>123</p> 中的 123；
  // 调用 updateHostText 函数，协调处理文本节点的内容更新；
  // 返回 null 表示已经是叶子节点，没有子节点了；
  const beginWork = (wip) => {
      //递归中的递
      switch (wip.tag) {
          case HostRoot:
              return updateHostRoot(wip);
          case HostComponent:
              return updateHostComponent(wip);
          case HostText:
              return null;
          default:
              {
                  console.warn("beginWork未实现的类型");
              }
              break;
      }
      return null;
  };
  function updateHostRoot(wip) {
      // 根据当前节点和工作中节点的状态进行比较，处理属性等更新逻辑
      const baseState = wip.memoizedState;
      const updateQueue = wip.updateQueue;
      const pending = updateQueue.shared.pending;
      // 清空更新链表
      updateQueue.shared.pending = null;
      // 计算待更新状态的最新值
      const { memoizedState } = processUpdateQueue(baseState, pending);
      wip.memoizedState = memoizedState;
      // 处理子节点的更新逻辑
      const nextChildren = wip.memoizedState;
      // reconcileChildren 函数的作用是，通过对比子节点的 current FiberNode 与 子节点的 ReactElement，
      // 来生成子节点对应的 workInProgress FiberNode。（current 是与视图中真实 UI 对应的 Fiber 树，
      // workInProgress 是触发更新后正在 Reconciler 中计算的 Fiber 树。）
      reconcileChildren(wip, nextChildren);
      // 返回新的子节点
      return wip.child;
  }
  function updateHostComponent(wip) {
      const nextProps = wip.pendingProps;
      const nextChildren = nextProps.children;
      reconcileChildren(wip, nextChildren);
      return wip.child;
  }
  // 对比子节点的 current FiberNode 与 子节点的 ReactElement
  // 生成子节点对应的 workInProgress FiberNode
  function reconcileChildren(wip, children) {
      // alternate 指向节点的备份节点，即 current
      const current = wip.alternate;
      if (current !== null) {
          //update
          // 组件的更新阶段
          // reconcileChildFibers 函数作用于组件的更新阶段，即当组件已经存在于 DOM 中，需要进行更新时。
          // 主要任务是协调处理当前组件实例的子节点，对比之前的子节点（current）和新的子节点（workInProgress）之间的变化。
          // 根据子节点的类型和 key 进行对比，决定是复用、更新、插入还是删除子节点，最终形成新的子节点链表。
          wip.child = reconcileChildFibers(wip, current?.child, children);
      }
      else {
          //mount
          // 首屏渲染阶段
          // mountChildFibers 函数作用于组件的首次渲染阶段，即当组件第一次被渲染到 DOM 中时。
          // 主要任务是协调处理首次渲染时组件实例的子节点。
          // 但此时是首次渲染，没有之前的子节点，所以主要是创建新的子节点链表。
          wip.child = mountChildFibers(wip, null, children);
      }
  }

  // export const createInstance = (type: string, props: any): Instance => {
  const createInstance = (type, props) => {
      // TODO 处理props
      const element = document.createElement(type);
      return element;
  };
  const appendInitialChild = (parent, child) => {
      parent.appendChild(child);
  };
  const createTextInstance = (content) => {
      return document.createTextNode(content);
  };
  const appendChildToContainer = appendInitialChild;

  let nextEffect = null;
  // commitMutationEffects 函数负责深度优先遍历 Fiber 树，递归地向下寻找子节点是否存在 Mutation 阶段需要执行的 flags，
  // 如果遍历到某个节点，其所有子节点都不存在 flags（即 subtreeFlags == NoFlags），则停止向下，
  // 调用 commitMutationEffectsOnFiber 处理该节点的 flags，并且开始遍历其兄弟节点和父节点。
  // commitMutationEffectsOnFiber 会根据每个节点的 flags 和更新计划中的信息执行相应的 DOM 操作。
  // 以 Placement 为例：如果 Fiber 节点的标志中包含 Placement，表示需要在 DOM 中插入新元素，
  // 此时就需要取到该 Fiber 节点对应的 DOM，并将其插入对应的父 DOM 节点中。
  const commitMutationEffects = (finishedWork) => {
      nextEffect = finishedWork;
      // 深度优先遍历 Fiber 树，寻找更新 flags
      while (nextEffect !== null) {
          //向下遍历
          const child = nextEffect.child;
          if ((nextEffect.subtreeFlags & MutationMask) !== NoFlags &&
              child !== null) {
              // 子节点存在 mutation 阶段需要执行的 flags
              nextEffect = child;
          }
          else {
              //向上遍历DFS
              // 子节点不存在 mutation 阶段需要执行的 flags 或没有子节点
              // 向上遍历
              up: while (nextEffect !== null) {
                  // 处理 flags
                  commitMutationEffectOnFiber(nextEffect);
                  const sibling = nextEffect.sibling;
                  // 遍历兄弟节点
                  if (sibling !== null) {
                      nextEffect = sibling;
                      break up;
                  }
                  // 遍历父节点
                  nextEffect = nextEffect.return;
              }
          }
      }
  };
  const commitMutationEffectOnFiber = (finishedWork) => {
      const flags = finishedWork.flags;
      if ((flags & Placement) !== NoFlags) {
          commitPlacement(finishedWork);
          finishedWork.flags &= -3;
      }
      if ((flags & Update) !== NoFlags) {
          // TODO Update
          finishedWork.flags &= -5;
      }
      if ((flags & ChildDeletion) !== NoFlags) {
          // TODO ChildDeletion
          finishedWork.flags &= -9;
      }
  };
  // 执行 DOM 插入操作，将 FiberNode 对应的 DOM 插入 parent DOM 中
  const commitPlacement = (finishedWork) => {
      {
          console.warn("执行Placement操作", finishedWork);
      }
      const hostParent = getHostParent(finishedWork);
      if (hostParent !== null) {
          appendPlacementNodeIntoContainer(finishedWork, hostParent);
      }
  };
  // 获取 parent DOM
  function getHostParent(fiber) {
      let parent = fiber.return;
      while (parent) {
          const parentTag = parent.tag;
          // 处理 Root 节点
          if (parentTag === HostComponent) {
              return parent.stateNode;
          }
          // 处理原生 DOM 元素节点 
          if (parentTag === HostRoot) {
              return parent.stateNode.container;
          }
          parent = parent.return;
      }
      {
          console.warn("未找到host parent");
      }
      return null;
  }
  function appendPlacementNodeIntoContainer(finishedWork, hostParent) {
      // fiber host
      if (finishedWork.tag === HostComponent || finishedWork.tag === HostText) {
          appendChildToContainer(hostParent, finishedWork.stateNode);
          return;
      }
      const child = finishedWork.child;
      if (child !== null) {
          appendPlacementNodeIntoContainer(child, hostParent);
          let sibling = child.sibling;
          while (sibling !== null) {
              appendPlacementNodeIntoContainer(sibling, hostParent);
              sibling = sibling.sibling;
          }
      }
  }

  // 生成更新计划，计算和收集更新 flags
  const completeWork = (wip) => {
      //递归中的归
      const newProps = wip.pendingProps;
      const current = wip.alternate;
      switch (wip.tag) {
          // 表示原生 DOM 元素节点；
          // 构建 DOM 节点，并调用 appendAllChildren 函数将 DOM 插入到 DOM 树中；
          // 收集更新 flags，并根据更新 flags 执行不同的 DOM 操作，例如插入新节点、更新节点属性、删除节点等；
          case HostComponent:
              if (current !== null && wip.stateNode) ;
              else {
                  // 首屏渲染阶段
                  // 构建 DOM
                  const instance = createInstance(wip.type);
                  // 将 DOM 插入到 DOM 树中
                  appendAllChildren(instance, wip);
                  wip.stateNode = instance;
              }
              // 收集更新 flags
              bubbleProperties(wip);
              return null;
          // 表示文本节点；
          // 构建 DOM 节点，并将 DOM 插入到 DOM 树中；
          // 收集更新 flags，根据 flags 的值，更新文本节点的内容；
          case HostText:
              if (current !== null && wip.stateNode) ;
              else {
                  // 首屏渲染阶段
                  // 构建 DOM
                  const instance = createTextInstance(newProps.content);
                  wip.stateNode = instance;
              }
              // 收集更新 flags
              bubbleProperties(wip);
              return null;
          // 表示根节点；
          // 会执行一些与根节点相关的最终操作，例如处理根节点的属性，确保整个应用更新完毕；
          case HostRoot:
              bubbleProperties(wip);
              return null;
          default:
              {
                  console.warn("未处理completeWork情况", wip);
              }
              break;
      }
  };
  function appendAllChildren(parent, wip) {
      let node = wip.child;
      while (node !== null) {
          if (node.tag === HostComponent || node.tag === HostText) {
              // 处理原生 DOM 元素节点或文本节点
              appendInitialChild(parent, node?.stateNode);
          }
          else if (node.child !== null) {
              // 递归处理其他类型的组件节点的子节点
              node.child.return = node;
              node = node.child;
              continue;
          }
          if (node === wip) {
              return;
          }
          while (node.sibling === null) {
              if (node.return === null || node.return === wip) {
                  return;
              }
              node = node?.return;
          }
          // 处理下一个兄弟节点
          node.sibling.return = node.return;
          node = node.sibling;
      }
  }
  // 收集更新 flags，将子 FiberNode 的 flags 冒泡到父 FiberNode 上
  function bubbleProperties(wip) {
      let subtreeFlags = NoFlags;
      let child = wip.child;
      while (child !== null) {
          subtreeFlags |= child.subtreeFlags;
          subtreeFlags |= child.flags;
          child.return = wip;
          child = child.sibling;
      }
      wip.subtreeFlags |= subtreeFlags;
  }

  let workInProgress;
  // 初始化 workInProgress 变量
  function prepareFreshStack(root) {
      workInProgress = createWorkInProgress(root.current, {});
  }
  function renderRoot(root) {
      // 初始化 workInProgress 变量
      prepareFreshStack(root);
      do {
          try {
              // 深度优先遍历
              workLoop();
              break;
          }
          catch (e) {
              {
                  console.warn("workLoop发生错误", e);
              }
              workInProgress = null;
          }
      } while (true);
      // 创建根 Fiber 树的 Root Fiber
      const finishedWork = root.current.alternate;
      // 提交阶段的入口函数
      root.finishedWork = finishedWork;
      commitRoot(root);
  }
  function commitRoot(root) {
      const finishedWork = root.finishedWork;
      if (finishedWork === null) {
          return;
      }
      {
          console.warn("commit阶段开始", finishedWork);
      }
      //重置
      root.finishedWork = null;
      //判断三个子阶段需要执行的操作
      //root flags root subtreeFlags
      const subtreeHasEffect = (finishedWork.subtreeFlags & MutationMask) !== NoFlags;
      const rootHasEffect = (finishedWork.flags & MutationMask) !== NoFlags;
      if (subtreeHasEffect || rootHasEffect) {
          // TODO: BeforeMutation
          //mutation Placement
          commitMutationEffects(finishedWork);
          // Fiber 树切换，workInProgress 变成 current
          root.current = finishedWork;
          // TODO: Layout
      }
      else {
          root.current = finishedWork;
      }
  }
  function scheduleUpdateOnFiber(fiber) {
      //调度功能
      //fiberRootNode
      const root = markUpdateFromFiberToRoot(fiber);
      renderRoot(root);
  }
  function markUpdateFromFiberToRoot(fiber) {
      let node = fiber;
      let parent = node.return;
      while (parent !== null) {
          node = parent;
          parent = node.return;
      }
      if (node.tag === HostRoot) {
          return node.stateNode;
      }
      return null;
  }
  // 深度优先遍历，向下递归子节点
  function workLoop() {
      while (workInProgress !== null) {
          performUnitOfWork(workInProgress);
      }
  }
  function performUnitOfWork(fiber) {
      // 比较并返回子 FiberNode
      const next = beginWork(fiber);
      fiber.memoizedProps = fiber.pendingProps;
      if (next === null) {
          // 没有子节点，则遍历兄弟节点或父节点
          completeUnitOfWork(fiber);
      }
      else {
          // 有子节点，继续向下深度遍历
          workInProgress = next;
      }
  }
  // 深度优先遍历兄弟节点或父节点
  function completeUnitOfWork(fiber) {
      let node = fiber;
      do {
          // 生成更新计划
          completeWork(node);
          // 有兄弟节点，则遍历兄弟节点
          const sibling = node.sibling;
          if (sibling !== null) {
              workInProgress = sibling;
              return;
          }
          // 否则向上返回，遍历父节点
          node = node.return;
          workInProgress = node;
      } while (node !== null);
  }

  // createContainer 函数: 用于创建一个新的容器（container），该容器包含了 React 应用的根节点以及与之相关的一些配置信息。
  // createContainer 函数会创建一个新的 Root 对象，该对象用于管理整个 React 应用的状态和更新。
  function createContainer(container) {
      const hostRootFiber = new FiberNode(HostRoot, {}, null); //根节点FiberNode
      const root = new FiberRootNode(container, hostRootFiber); //根元素、根节点FiberNode
      hostRootFiber.updateQueue = createUpdateQueue();
      return root;
  }
  // updateContainer 函数: 用于更新已经存在的容器中的内容。在内部，updateContainer
  // 函数会调用 scheduleUpdateOnFiber 等方法，通过 Fiber 架构中的协调更新过程，
  // 将新的 React 元素（element）渲染到容器中，并更新整个应用的状态。
  function updateContainer(element, root) {
      const hostRootFiber = root.current;
      const update = createUpdate(element);
      //入队
      enqueueUpdate(hostRootFiber.updateQueue, update);
      scheduleUpdateOnFiber(hostRootFiber);
      return element;
  }

  // ReactDOM.createRoot(root).render(<App/>)
  function createRoot(container) {
      const root = createContainer(container);
      //FiberRootNode
      return {
          render(element) {
              return updateContainer(element, root);
          },
      };
  }

  var ReactDom = /*#__PURE__*/Object.freeze({
    __proto__: null,
    createRoot: createRoot
  });

  return ReactDom;

}));
