1.React 是如何实现类似于 requestIdleCallback，在空闲时期执行代码的效果？
1.1React16 使用（requestAnimationFrame + postMessage）
window.postMessage() 方法可以安全地实现跨源通信。
window.addEventListener("message", (e) => {console.log(e.data)}, false);
window.postMessage('Hello World!')
通过 postMessage 进行通信，通信的内容并不重要，重点是浏览器会被推入一个宏任务。我们之想要实现空闲时期执行，想要达到的效果是不阻碍浏览器对动画和用户输入的处理，我们没有直接执行 callback 回调，而是用 postMessage 推入到任务列表中，浏览器就可以响应更高优先级的动画或者用户输入，等执行完再去我们推入的任务。
1.2React 18 使用 message loop
web 通信（web messaging）有两种方式，一种是跨文档通信(cross-document messaging)，也就是我们熟知的 window.postMessage()，常被用于与 iframe 之间的通信，一种是通道通信（channel messaging），也就是 MessageChannel，MessageChannel 也是宏任务。
var channel = new MessageChannel();
channel.port1.onmessage = (e) => {console.log(e.data)}
channel.port2.postMessage('Hello World')

React 把 React 的更新操作做成了一个个任务，塞进了 taskQueue，也就是任务列表，如果直接遍历执行这个任务列表，纯同步操作，执行期间，浏览器无法响应动画或者用户的输入，于是借助 MessageChannel，依然是遍历执行任务，但当每个任务执行完，就会判断过了多久，如果没有过默认的切片时间（5ms），那就再执行一个任务，如果过了，那就调用 postMessage，让出线程，等浏览器处理完动画或者用户输入，就会执行 onmessage 推入的任务，接着遍历执行任务列表。

2.React 为什么采用最小堆结构呢？
这是因为在最小堆结构中，最小值就在第一个，React 可以快速的取出最小值。
3.React 为什么要取出最小值而不是最大值呢？
我们可以这样设想，React 将更新任务拆成多个小任务，每个小任务的数据结构是一个带着 expirationTime 的对象，expirationTime 表示这个任务的过期时间，expirationTime 越小就表示过期时间越近，该任务的优先级就越高，取出最小值就相当于取出优先级最高的任务。

4.React 有一套优先级，Scheduler 也有一套优先级
