1.16.6ms
显示器的刷新率是指显示器每秒绘制新图像的次数。其单位为赫兹 (Hz)。赫兹（符号：Hz）则是国际单位制中频率的单位，表示每一秒周期性事件发生的次数。
如果显示器刷新率为 144Hz，指的就是显示器每秒钟会刷新图像 144 次。

大我们一定会听过 16ms 这个说法，致是浏览器的刷新频率是 60Hz，每帧就是 1000ms / 60Hz = 16.6ms，所以 JavaScript 的操作要在 16.6ms 内完成，否则用户就会感到卡顿。

而对于一帧来说，如果要保证流畅性，浏览器确实要在 16.6ms 内完成输出一个画面，但这个时间并不都是留给 JavaScript 的，我们学习浏览器渲染原理的时候，你可以看到，在一帧里，浏览器要处理用户输入事件、执行脚本、处理窗口变更、滚动、媒体查询、动画、执行 requestAnimationFrame 和 Intersection-Observer 回调、布局计算、绘制等，留给 JS 执行的时间并不多，在 React 中默认的时间切片时间也只有 5ms。

2.requestAnimationFrame
window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行
requestAnimationFrame 的执行时机在 JS 之后，Layout、Paint 之后。requestAnimationFrame 每帧只会执行 1 次。

<!--
import useAnimationFrame from 'use-animation-frame';
const Counter = () => {
    const [time, setTime] = useState(0);
    useAnimationFrame(e => setTime(e.time));
    return <div>Running for:<br/>{time.toFixed(1)}s</div>;
};
-->

<!-- (useAnimationFrame源码)
import { useLayoutEffect, useRef } from "react";
// Reusable component that also takes dependencies
export default (cb) => {
  if (typeof performance === "undefined" || typeof window === "undefined") {
    return;
  }

  const cbRef = useRef();
  const frame = useRef();
  const init = useRef(performance.now());
  const last = useRef(performance.now());

  cbRef.current = cb;

  const animate = (now) => {
    // In seconds ~> you can do ms or anything in userland
    cbRef.current({
      time: (now - init.current) / 1000,
      delta: (now - last.current) / 1000,
    });
    last.current = now;
    frame.current = requestAnimationFrame(animate);
  };

  useLayoutEffect(() => {
    frame.current = requestAnimationFrame(animate);
    return () => frame.current && cancelAnimationFrame(frame.current);
  }, []);
};
-->

3.requestIdleCallback
window.requestIdleCallback() 方法插入一个函数，这个函数将在浏览器空闲时期（idle periods）被调用。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。
var handle = window.requestIdleCallback(callback[, options])
其中： handle 表示返回的 ID，可以把它传入 Window.cancelIdleCallback() 方法来结束回调
callback 表示一个在事件循环空闲时即将被调用的函数的引用。函数会接收到一个名为 IdleDeadline 的参数，这个参数可以获取当前空闲时间以及回调是否在超时时间前已经执行的状态。
options 表示可选的配置参数，目前只有一个 timeout，如果指定了 timeout，并且有一个正值，而回调在 timeout 毫秒过后还没有被调用，那么回调任务将放入事件循环中排队。

<!--
deadline 参数，它有一个 didTimeout 属性，表示回调是否在超时时间前已经执行，它还有一个 timeRemaining() 函数，表示当前闲置周期的预估剩余毫秒数，
requestIdleCallback((deadline) => {
   console.log(deadline)
}, {timeout: 1000})
-->

4.requestIdleCallback 的执行时机
(1).在完成一帧中的输入处理、渲染和合成之后，线程会进入空闲时期（idle period），直到下一帧开始，或者队列中的任务被激活，又或者收到了用户新的输入。requestIdleCallback 定义的回调就是在这段空闲时期执行。这样的空闲时期通常会在动画（active animations）和屏幕刷新（screen updates）中频繁出现，但一般时间都非常短。(比如：在 60Hz 的设备下小于 16ms)
(2).另外一个空闲时期的例子是当没有屏幕刷新出现的时候，在这种情况下，因为没有任务出现限制空闲时期的时间，但为了避免出现不可预知的任务（比如用户输入）导致用户可感知的延迟，空闲时期会被限制为最长 50ms，当一个 50ms 空闲时期结束后，如果还是空闲状态，就会再开启一个 50ms 的空闲时期

5.requestIdleCallback 和 requestFrameAnimation 的区别
requestIdleCallback 和 requestFrameAnimation 的用法是不一样的，我们用 requestFrameAnimation 的时候通常是做动画，每帧执行一个样式修改，但 requestIdleCallback 是用来处理低优先级的任务的，我们会把任务做成一个队列，只要还有空闲时间，我们就持续执行队列里的任务，所以 requestIdleCallback 虽然调用次数少，但在一次 requestIdleCallback 中，我们可能会完成很多任务。

6.requestIdleCallback 非常适合用于一些低优先级的任务，比如你不希望数据统计相关的代码阻碍了代码执行，那就可以放到 requestIdleCallback 中执行。但是要注意一点的是：避免在空闲回调中改变 DOM。 空闲回调执行的时候，当前帧已经结束绘制了，所有布局的更新和计算也已经完成。如果你做的改变影响了布局，你可能会强制停止浏览器并重新计算，而从另一方面来看，这是不必要的。如果你的回调需要改变 DOM，它应该使用 Window.requestAnimationFrame()来调度它。
