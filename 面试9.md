1.createContext useContext
useContext 也不能再条件语句中使用，如果想在条件语句中使用，可以用 use。context 的存储结构也是一个链表
多层 context 嵌套的场景

<!-- const ctxA = createContext("default A");
     const ctxB = createContext("default B"); -->

<!-- <ctxA.Provider value={"A0"}>
        <ctxB.Provider value={"B0"}>
            <ctxA.Provider value={"A1"}>
                <Cpn />
            </ctxA.Provider>
        </ctxB.Provider>
        <Cpn />
    </ctxA.Provider>
-->

//用一个栈结构记录一下之前的 prevContextValue
//beginWork 的递的过程中 把之前的 prevContextValue 推到栈中 [null,'default A','default B'] prevContextValue='A0'
//beginWork 会把 Context 的值改成新传进来的值
//递的过程组件内用的就是最新的 context
//completeWork
//prevContextValue 依次出栈，context 恢复成上一次的值，最终执行 completeWork(归)完毕后，context 就会恢复成原来的值(default A、default B)

2.Suspense

<!--
<Suspense fallback={<div>loading</div>}>
    <Cpn />
</Suspense>
-->

正常状态：<Suspense/>渲染子孙组件
挂起状态：<Suspense/>渲染 fallback
其中，早场挂起状态的原因有很多,比如：
<Cpn/>或者其子孙组件是懒加载组件
<Cpn/>或者其子孙组件触发并发更新(useTransition)
<Cpn/>货期子孙是 Selective Hydration
<Cpn/>或者其子孙使用 use 请求数据
总结：凡是涉及到 初始状态 -> 中间状态 -> 结束状态 的过程 都可以纳入到<Suspense/>
