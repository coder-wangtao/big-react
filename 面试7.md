1.React 是如何实现类似于 requestIdleCallback，在空闲时期执行代码的效果？
1.1React16 使用（requestAnimationFrame + postMessage）
window.postMessage() 方法可以安全地实现跨源通信。
window.addEventListener("message", (e) => {console.log(e.data)}, false);
window.postMessage('Hello World!')
通过 postMessage 进行通信，通信的内容并不重要，重点是浏览器会被推入一个宏任务。我们之想要实现空闲时期执行，想要达到的效果是不阻碍浏览器对动画和用户输入的处理，我们没有直接执行 callback 回调，而是用 postMessage 推入到任务列表中，浏览器就可以响应更高优先级的动画或者用户输入，等执行完再去我们推入的任务。
1.2React 18 使用 message loop
web 通信（web messaging）有两种方式，一种是跨文档通信(cross-document messaging)，也就是我们熟知的 window.postMessage()，常被用于与 iframe 之间的通信，一种是通道通信（channel messaging），也就是 MessageChannel，MessageChannel 也是宏任务。
var channel = new MessageChannel();
channel.port1.onmessage = (e) => {console.log(e.data)}
channel.port2.postMessage('Hello World')

React 把 React 的更新操作做成了一个个任务，塞进了 taskQueue，也就是任务列表，如果直接遍历执行这个任务列表，纯同步操作，执行期间，浏览器无法响应动画或者用户的输入，于是借助 MessageChannel，依然是遍历执行任务，但当每个任务执行完，就会判断过了多久，如果没有过默认的切片时间（5ms），那就再执行一个任务，如果过了，那就调用 postMessage，让出线程，等浏览器处理完动画或者用户输入，就会执行 onmessage 推入的任务，接着遍历执行任务列表。

2.React 为什么采用最小堆结构呢？
这是因为在最小堆结构中，最小值就在第一个，React 可以快速的取出最小值。
3.React 为什么要取出最小值而不是最大值呢？
我们可以这样设想，React 将更新任务拆成多个小任务，每个小任务的数据结构是一个带着 expirationTime 的对象，expirationTime 表示这个任务的过期时间，expirationTime 越小就表示过期时间越近，该任务的优先级就越高，取出最小值就相当于取出优先级最高的任务。

4.React 有一套优先级，Scheduler 也有一套优先级
//普通任务
// 当创建一个调度任务的时候（unstable_scheduleCallback），会传入优先级（priorityLevel）、执行函数（callback），可选项（options），
// React 会根据任务优先级创建 task 对象，并根据可选项中的 delay 参数判断是将任务放到普通任务队列（taskQueue），还是延时任务队列（timerQueue）。
// 当放到普通任务队列后，便会执行 requestHostCallback(flushWork)，requestHostCallback 的作用是借助 Message Channel 将线程让出来，
// 让浏览器可以处理动画或者用户输入，当浏览器空闲的时候，便会执行 flushWork 函数，flushWork 的作用是执行任务队列里的任务，它会执行 advanceTimers，
// 不断地将 timerQueue 中到期的任务添加到 taskQueue，它会执行 taskQueue 中优先级最高的任务，当任务函数执行完毕之后，它会判断过了多久，
// 如果时间还没有到一个切片时间（5ms），便会执行队列里的下个优先级最高的任务，一直到超出切片时间，当超出时间之后，React 会让出线程，
// 等待浏览器下次继续执行 flushWork，也就是再次遍历执行任务队列，直到任务队列中的任务全部完成。

//延时任务
当我们创建一个延时任务后，我们将其添加到 timerQueue 中，我们使用 requestHostTimeout 来安排调度，requestHostTimeout 本质是一个 setTimeout，当时间到期后，
执行 handleTimeout，将到期的任务转移到 taskQueue，然后按照普通任务的执行流程走。
我们在执行 flushWork 的时候，如果有正在执行的定时器，我们会执行 cancelHostTimeout 取消定时器，这里为什么要取消呢？
定时器的目的表面上是为了保证最早的延时任务准时安排调度，实际上是为了保证 timerQueue 中的任务都能被执行。定时器到期后，我们会执行 advanceTimers 和 flushWork，flushWork 中会执行 workLoop，workLoop 中会将 taskQueue 中的任务不断执行，当 taskQueue 执行完毕后，workLoop 会选择 timerQueue 中的最早的任务重新设置一个定时器。所以如果 flushWork 执行了，定时器也就没有必要了，所以可以取消了。

5.将很长的可能掉帧的一个长的宏任务切成很多短的可能不会掉帧的宏任务，这里时间切片的理论基础。
